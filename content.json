{"meta":{"title":"欧阳帆","subtitle":null,"description":"kaka的博客","author":"kaka","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Web性能优化的常用手段","slug":"Web性能优化的常用手段","date":"2019-06-26T06:44:32.000Z","updated":"2019-06-26T08:13:03.568Z","comments":true,"path":"2019/06/26/Web性能优化的常用手段/","link":"","permalink":"http://yoursite.com/2019/06/26/Web性能优化的常用手段/","excerpt":"","text":"Web性能优化的常用手段1.前言在前端领域，Web性能是个很热门的话题，从初级工程师到技术大牛都热衷于讨论性能优化，关于Web性能优化的文章也经常出现在各大论坛和社区中。本文从输入 URL 到页面呈现，到底发生了什么这个常见的面试题出发，来简单聊聊Web性能优化的常用手段。 2.输入 URL 到页面呈现，到底发生了什么？1.判断是否有缓存，如果有缓存，则读取缓存 2.DNS解析 3.建立TCP连接 4.发送HTTP请求 5.服务器接收请求，进行后端的对应处理，返回响应 6.客户端接收响应 7.浏览器开始逐行解析文件。 8.文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行。 9.CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了。 上面只是简单分析了下从输入URL到页面呈现发生了什么，但是我们必须理解几件事： 从域名到IP地址，需要用DNS协议查询 HTTP 协议是用 TCP 传输的，所以会有 TCP 建立连接过程 如果使用 HTTPS，还有有 HTTPS 交换证书； 每个网页还有JS,CSS,图片等资源请求。 3.Web性能优化的技术方案划分网页的加载时间，不但和体积有关系，还跟请求数有很多关系，因此关于Web性能优化的性能优化技术方案可以这样划分 4.Web性能优化的常用手段介绍4.1缓存4.1.1DNS缓存DNS查询被缓存来提高性能。这种缓存可能发生在特定的缓存服务器（ISP/local area network维护），或者用户的计算机。DNS信息留存在操作系统DNS缓存中（在windows中就是 DNS Client Serve ）。大多浏览器有自己的缓存，独立于操作系统缓存。只要浏览器在自己的缓存里有某条DNS记录，它就不会向操作系统发DNS解析请求。 IE默认缓存DNS记录30分钟，FireFox默认缓存1分钟。 4.1.2加上 Expires 或者Cache-Control 请求头这条规则有两个方面： 对静态组件：通过设置Expires头部来实现“永不过期”策略。 对动态组件：用合适的Cache-Control头部来帮助浏览器进行有条件请求。 页面越来越丰富，意味着更多脚本，样式，图片等等。第一次访问的用户可能需要发出多个请求，但使用Expires可以让这些组件被缓存。这避免了访问子页面时没必要的http请求。Expires一般用在图片上，但应该用在所有的组件上。 浏览器（以及代理）使用缓存来减少http请求数，加快页面加载。服务器使用http响应的Expires头部来告诉客户端一个组件可以缓存多久。比如下面： 1Expires: Thu, 15 Apr 2010 20:00:00 GMT //2010-04-15之前都是稳定的 注意，如果你设置了Expires头部，当组件更新后，你必须更改文件名。 4.1.3使用ETags实体标记（Entity tags，ETag）是服务器和浏览器之间判断浏览器缓存中某个组件是否匹配服务器端原组件的一种机制。实体就是组件：图片，脚本，样式等等。ETag被当作验证实体的比最后更改（last-modified）日期更高效的机制。服务器这样设置组件的ETag： 1234HTTP/1.1 200 OKLast-Modified: Tue, 12 Dec 2006 03:03:59 GMTETag: &quot;10c24bc-4ab-457e1c1f&quot;Content-Length: 12195 之后，如果浏览器要验证组件，它用If-None-Match头部来传ETag给服务器。如果ETag匹配，服务器返回304： 12345GET /i/yahoo.gif HTTP/1.1Host: us.yimg.comIf-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMTIf-None-Match: &quot;10c24bc-4ab-457e1c1f&quot;HTTP/1.1 304 Not Modified ETag的问题是它们被构造来使它们对特定的运行这个网站的服务器唯一。浏览器从一个服务器获取组件，之后向另一个服务器验证，ETag将不匹配。然而服务器集群是处理请求的通用解决方案。 如果不能解决多服务器间的ETag匹配问题，那么删除ETag可能更好。 4.1.4让Ajax可缓存让Ajax可缓存。 使用ajax的好处是可以向用户提供很快的反馈，因为它是向后台异步请求数据。但是，这些异步请求不保证用户等待的时间——异步不意味着瞬时。 提高ajax性能的最重要的方法是让响应被缓存 4.2降低请求成本4.2.1使用cdn用户接近你的服务器会减少响应时间。把你的内容发布到多个，地理上分散的服务器可以让页面加载更快。但怎么开始？ 首先不要试图把你的架构重新设计成分布式架构。因为可能引进更多复杂性和不可控。 记住80-90%的终端用户响应时间花费在下载页面中的所有组件：图片、样式、脚本、falsh等等。这是Performance Golden Rule。不要从困难的重新设计后台架构开始，最好首先分发你的静态内容。这不仅可以减少响应时间，用CDN还很容易来做。 CDN是一群不同地点的服务器，可以更高效地分发内容到用户。一些大公司有自己的CDN。 4.2.2 TCP连接复用HTTP1.1使用Keep-Alive，在一定时间内，同一域名多次请求数据，只建立一次HTTP请求，其他请求可复用每一次建立的连接通道，以达到提高请求效率的问题。这里面所说的一定时间是可以配置的，不管你用的是Apache还是nginx。 但HTTP1.1还是存在效率问题 如上面所说，在HTTP1.1中是默认开启了Keep-Alive，他解决了多次连接的问题，但是依然有两个效率上的问题： 第一个：串行的文件传输。当请求a文件时，b文件只能等待，等待a连接到服务器、服务器处理文件、服务器返回文件，这三个步骤。我们假设这三步用时都是1秒，那么a文件用时为3秒，b文件传输完成用时为6秒，依此类推。（注：此项计算有一个前提条件，就是浏览器和服务器是单通道传输） 第二个：连接数过多。我们假设Apache设置了最大并发数为300，因为浏览器限制，浏览器发起的最大请求数为6，也就是服务器能承载的最高并发为50，当第51个人访问时，就需要等待前面某个请求处理完成。 于是我们可以引入HTTP/2的多路复用 HTTP/2的多路复用就是为了解决上述的两个性能问题，我们来看一下，他是如何解决的。 解决第一个：在HTTP1.1的协议中，我们传输的request和response都是基本于文本的，这样就会引发一个问题：所有的数据必须按顺序传输，比如需要传输：hello world，只能从h到d一个一个的传输，不能并行传输，因为接收端并不知道这些字符的顺序，所以并行传输在HTTP1.1是不能实现的。 HTTP/2引入二进制数据帧和流的概念，其中帧对数据进行顺序标识，如下图所示，这样浏览器收到数据之后，就可以按照序列对数据进行合并，而不会出现合并后数据错乱的情况。同样是因为有了序列，服务器就可以并行的传输数据，这就是流所做的事情。 解决第二个问题：HTTP/2对同一域名下所有请求都是基于流，也就是说同一域名不管访问多少文件，也只建立一路连接。同样Apache的最大连接数为300，因为有了这个新特性，最大的并发就可以提升到300，比原来提升了6倍！ 4.2.3多域名提高浏览器的下载速度把组件分散到不同的域名允许你最大化并行下载数。由于DNS查询的副作用，最佳的不同域名数是2-4。这样浏览器就可以对不同域名下的多个文件同时进行下载，避免了浏览器6个通道的限制，这样做的缺点也是明显的，1.DNS的解析时间会变长。2.增加了服务器的压力。有了HTTP/2之后，根据上面讲的原理，我们就不用这么搞了，成本会更低。 4.3减少请求数4.3.1减少HTTP请求数到终端用户的响应时间80%花在前端：大部分用于下载组件（js/css/image/flash等等）。减少组件数就是减少渲染页面所需的http请求数。这是更快页面的关键。 减少组件数的一个方法就是简化页面设计。保持富内容的页面且能减少http请求，有以下几个技术： Combined files。合并文件，如合并js，合并css都能减少请求数。如果页面间脚本和样式差异很大，合并会更具挑战性。 CSS Sprites。雪碧图可以合并多个背景图片，通过background-image 和 background-position 来显示不同部分。 Image maps。合并多个图片到一个图片，一般用于如导航条。由于定义坐标的枯燥和易错，一般不推荐。 Inline images。使用data:url scheme来內连图片。 减少请求数是为第一次访问页面的用户提高性能的最重要的指导 4.3.2减少DNS查询减少DNS请求数可能会减少并行下载数。避免DNS查找减少响应时间，但减少并行下载数可能会增加响应时间。指导原则是组件可以分散在至少2个但不多于4个的不同域名。这是两者的妥协。 4.3.3延迟加载组件再看看你的页面然后问问自己，“什么是页面初始化必须的？”。剩下的内容和组件可以延迟。 JavaScript是理想的（延迟）候选者，可以切分到onload事件之前和之后。比如拖放的js库可以延迟，因为拖动必须在页面初始化之后。其它可延迟的包括隐藏的内容，折叠起来的图片等等。 4.3.4预加载组件预加载看起来与延迟加载相反，但它的确有个不同的目标。通过预加载你可以利用浏览器的空闲时间来请求你将来会用到的组件。这样当用户访问下一个页面时，你会有更多的组件已经在缓存中，这样会极大加快页面加载。 有几种预加载类型： 无条件预加载：一旦onload触发，你立即获取另外的组件。比如谷歌会在主页这样加载搜索结果页面用到的雪碧图。 有条件预加载：基于用户动作，你推测用户下一步会去哪里并加载相应组件。 预期的预加载：在发布重新设计（的网站）前提前加载。在旧网页预加载新网页的部分组件，那么切换到新网页时就不会是没有任何缓存了。 4.4减少传输体积4.4.1传输时用gzip等压缩组件http请求或响应的传输时间可以被前端工程师显著减少。终端用户的带宽，ISP，接近对等交换点等等没法被开发团队控制，但是，压缩可以通过减少http响应的大小减少响应时间。 从HTTP/1.1开始，客户端通过http请求中的Accept-Encoding头部来提示支持的压缩： 1Accept-Encoding: gzip, deflate 如果服务器看到这个头部，它可能会选用列表中的某个方法压缩响应。服务器通过Content-Encoding头部提示客户端： 1Content-Encoding: gzip gzip一般可减小响应的70%。尽可能去gzip更多（文本）类型的文件。html，脚本，样式，xml和json等等都应该被gzip，而图片，pdf等等不应该被gzip，因为它们本身已被压缩过，gzip它们只是浪费cpu，甚至增加文件大小。 4.4.2减少Cookie大小http cookie的使用有多种原因，比如授权和个性化。cookie的信息通过http头部在浏览器和服务器端交换。尽可能减小cookie的大小来降低响应时间。 消除不必要的cookie。 尽可能减小cookie的大小来降低响应时间。 注意设置cookie到合适的域名级别，则其它子域名不会被影响。 正确设置Expires日期。早一点的Expires日期或者没有会尽早删除cookie，优化响应时间。 4.4.3对图片的处理 尽量使用SVG/gradient等代替图片 根据机型和网络状况控制图片清晰度 对低清晰度图片使用锐化来提升体验 设计上避免大型背景图 4.4.4压缩JS和CSS压缩就是删除代码中不必要的字符来减小文件大小，从而提高加载速度。当代码压缩时，注释删除，不需要的空格（空白，换行，tab）也被删除。 混淆是对代码可选的优化。它比压缩更复杂，并且可能产生bug。在对美国top10网站的调查，压缩可减小21%，而混淆可减小25%。 除了外部脚本和样式，內连的脚本和样式同样应该被压缩。 4.5 CSS的加载策略把样式放在顶部。关注性能的前端工程师希望页面被逐步渲染，这时因为，我们希望浏览器尽早渲染获取到的任何内容。这对大页面和网速慢的用户很重要。给用户视觉反馈，比如进度条的重要性已经被大量研究和记录。在我们的情况中，HTML页面就是进度条。当浏览器逐步加载页面头部，导航条，logo等等，这些都是给等待页面的用户的视觉反馈。这优化了整体用户体验。 把样式表放在文档底部的问题是它阻止了许多浏览器的逐步渲染，包括IE。这些浏览器阻止渲染来避免在样式更改时需要重绘页面元素。所以用户会卡在白屏。 4.6 JS的加载策略把脚本放到底部。 脚本引起的问题是它们阻塞了并行下载。HTTP1.1规范建议浏览器每个域名下不要一次下载超过2个组件。如果你的图片分散在不同服务器，那么你能并行下载多个图片。但当脚本在下载，浏览器不会再下载其它组件，即使在不同域名下。 有些情况下把脚本移动到底部并不简单。比如，脚本中用了document.write来插入内容，它就不能被移动到底部。另外有可能有作用域问题。但大多数情况，有方法可以解决这些问题。 一个替代建议是使用异步脚本。defer属性表明脚本不包含document.write，是提示浏览器继续渲染的线索。不幸的是，Firefox不支持。如果脚本能异步，那么也就可以移动到底部。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"web性能优化","slug":"web性能优化","permalink":"http://yoursite.com/tags/web性能优化/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"Javascript的继承","slug":"Javascript的继承","date":"2019-06-26T05:45:20.000Z","updated":"2019-06-26T06:46:42.769Z","comments":true,"path":"2019/06/26/Javascript的继承/","link":"","permalink":"http://yoursite.com/2019/06/26/Javascript的继承/","excerpt":"","text":"Javascript的继承1.前言Javascript本质上不能算是一门面向对象的编程语言，因为它对于类、继承、多态这些面向对象语言的特点并没有在语言层面上提供原生的支持。但是，从面向对象的设计思想触发，我们可以根据Javascript原型(prototype)的概念以另一种方式模仿类，并通过原型链的方式实现了父类子类之间共享属性的继承以及身份确认机制。所幸，es6增加了class、extends、static等关键字用以在语言层面支持面向对象。本文先分别列出使用prototype和es6的class语法糖实现继承的方案，然后比较这两种方案各自的区别。 2.ES5使用原型链和构造函数实现组合继承12345678910111213141516171819function Human(name)&#123; this.name = name || \"default name\"&#125;Human.prototype.run = function()&#123; console.log(\"我叫\"+this.name+\"，我在跑\") return undefined&#125;function Man(name)&#123; Human.call(this, name) this.gender = '男'&#125;Man.prototype = new Human()Man.prototype.fight = function()&#123; console.log('糊你熊脸')&#125;var man1=new Man(\"Fanoy\"); 这个例子很简单，这样不仅会继承构造函数中的属性，也会复制父类原型链中的属性。但是，有个问题，Man.prototype = new Human(); 这句执行后，Man的原型如下： 12&gt; Man.prototype&gt; &#123;name: \"default name\"&#125; 也就是说Man的原型中已经有了一个name属性，而之后创建man1时传给构造的函数的name则是通过this重新定义了一个name属性，相当于只是覆盖掉了原型的name属性（原型中的name依然还在），这样很不优雅。于是我们有了下面改进的代码: 123456789101112131415161718192021function Human(name)&#123; this.name = name || \"default name\"&#125;Human.prototype.run = function()&#123; console.log(\"我叫\"+this.name+\"，我在跑\") return undefined&#125;function Man(name)&#123; Human.call(this, name) this.gender = '男'&#125;var f = function()&#123;&#125;f.prototype = Human.prototypeMan.prototype = new f()Man.prototype.fight = function()&#123; console.log('糊你熊脸')&#125;var man1=new Man(\"Fanoy\"); 我们声明了一个空函数f,并且让f.prototype = Human.prototype，而Man.prototype=new f()`由于f是一个空函数没有任何自己的属性，所以Man.prototype不会继承任何多余属性，问题得以解决。 3.ES6的class语法糖写法1234567891011121314151617class Human&#123; constructor(name)&#123; this.name = name || \"default name\" &#125; run()&#123; console.log(\"我叫\"+this.name+\"，我在跑\") &#125; &#125; class Man extends Human&#123; constructor(name)&#123; super(name) this.gender = '男' &#125; fight()&#123; console.log('糊你熊脸') &#125; &#125; 熟悉java的可能对上面的代码感觉很亲切，几乎是自解释的。大概解释一下，按照代码中标号对应： constructor为构造函数，一个类有一个，相当于es5中构造函数标准化，负责一些初始化工作，如果没有定义，js vm会定义一个空的默认的构造函数。 实例方法，es6中可以不加”function”关键字，class内定义的所有函数都会置于该类的原型当中，所以，class本身只是一个语法糖。 构造函数中通过super()调用父类构造函数，如果有super方法，需要时构造函数中第一个执行的语句，this关键字在调用super之后才可用。 4.ES5和ES6继承方案的各自优缺点4.1.ES5组合继承的优点ES5中组合继承的思想是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。组合继承避免了原型链和借用构造函数的缺陷，成为ES6之前最常用的继承模式。 4.2.ES5组合继承的缺点为了避免子类原型上多余共有属性的问题让方案变得比较难理解，不够自然。 4.3.ES6继承的优点而ES6的class语法糖写法与ES5组合继承相比，在语言层面上提供了面向对象的部分支持，虽然大多数时候只是一个语法糖，但使用起来更方便，语意化更强、更直观，同时也给javascript继承提供一个标准的方式。还有很重要的一点就是－es6支持原生对象继承。 4.4.ES6继承的缺点 不支持静态属性（除函数）。 class中不能定义私有变量和函数。class中定义的所有函数都会被放倒原型当中，都会被子类继承，而属性都会作为实例属性挂到this上。如果子类想定义一个私有的方法或定义一个private 变量，便不能直接在class花括号内定义，这真的很不方便！","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"JS数据类型转换之装箱拆箱","slug":"JS数据类型转换之装箱拆箱","date":"2019-05-24T04:28:37.000Z","updated":"2019-05-24T04:56:43.326Z","comments":true,"path":"2019/05/24/JS数据类型转换之装箱拆箱/","link":"","permalink":"http://yoursite.com/2019/05/24/JS数据类型转换之装箱拆箱/","excerpt":"","text":"JS数据类型转换之装箱拆箱装箱转换每一种基本类型 Number、String、Boolean、Symbol在对象中都有对应的类，所谓装箱转换，正事把基本数据类型转换为对应的对象，它是类型转换中一种相当重要的种类。 由于全局的Symbol函数无法使用new来调用，但是我们仍然可以利用装箱机制来得到一个Symbol对象，我们可以利用一个函数的call方法来强制装箱。 定义一个函数，函数里面只有return this,然后我们调用函数的call方法到一个Symbol类型的值上，这样就可以产生一个Symbol对象。 12345var symbolObject = (function()&#123; return this; &#125;).call(Symbol('symbol'));typeof symbolObject //'object'symbolObject instanceof Symbol //truesymbolObject.construtor == Symbol //true 装箱机制会频繁产生临时对象，在一些对性能要求较高的场景下，我们应该尽量避免对基本类型做装箱转换。 使用内置的Object函数可以在JS代码中显式调用装箱。 12345var symbolObject = Object(Symbol('symbol'));typeof symbolObject //'object'symbolObject instanceof Symbol //truesymbolObject.construtor == Symbol //true 每一种装箱对象都有私有的Class属性，这些属性可以用Object.prototype.toString获取： 123var symbolObject = Object(Symbol('symbol'));Object.prototype.toString.call(symbolObject); //[object Symbol] 在JS中没有任何方法可以修改私有的Class属性，因此使用Object.prototype.toString比instanceof更能准确识别对象对应的基本类型。但call本身会产生装箱操作，所以需要配合typeof来区分基本类型还是对象类型。 拆箱操作在 JS 标准中，规定了 ToPrimitive函数，它是对象类型到基本类型的转换，即拆箱操作。 对象到 String 和 Number 的转换都遵循“先拆箱再转换”的规则。通过拆箱转换，把对象变成基本类型，再从基本类型转换为对应的 String 或者 Number。 拆箱转换会尝试调用 valueOf 和 toString 来获得拆箱后的基本类型。如果 valueOf 和 toString 都不存在，或者没有返回基本类型，则会产生类型错误 TypeError。 1234567891011121314var o = &#123; valueOf : () =&gt; &#123;console.log(\"valueOf\"); return &#123;&#125;&#125;, toString : () =&gt; &#123;console.log(\"toString\"); return &#123;&#125;&#125;&#125;o * 2// valueOf// toString// TypeErroro + ''// valueOf// toString// TypeError 到 String 的拆箱转换会优先调用 toString。我们把刚才的运算从 o*2 换成 String(o)，那么你会看到调用顺序就变了。 123456789var o = &#123; valueOf : () =&gt; &#123;console.log(\"valueOf\"); return &#123;&#125;&#125;, toString : () =&gt; &#123;console.log(\"toString\"); return &#123;&#125;&#125;&#125; String(o)// toString// valueOf// TypeError 在 ES6 之后，还允许对象通过显式指定Symbol.toPrimitive来覆盖原有的行为。 12345678910var o = &#123; valueOf : () =&gt; &#123;console.log(\"valueOf\"); return &#123;&#125;&#125;, toString : () =&gt; &#123;console.log(\"toString\"); return &#123;&#125;&#125;&#125;o[Symbol.toPrimitive] = () =&gt; &#123;console.log(\"toPrimitive\"); return \"hello\"&#125;;console.log(o + \"\")// toPrimitive// hello","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"用公式理解JS原型链","slug":"用公式理解JS原型链","date":"2019-05-22T08:31:27.000Z","updated":"2019-05-22T08:44:28.825Z","comments":true,"path":"2019/05/22/用公式理解JS原型链/","link":"","permalink":"http://yoursite.com/2019/05/22/用公式理解JS原型链/","excerpt":"","text":"用公式理解JS原型链重要公式 123456789101112131415161718var 对象 = new 构造函数();对象.__proto__ === 构造函数.protoType //true//推论var number = new Number();number.__proto__ === Number.protoType //truevar object = new Object()object.__proto__ === Object.prototype //truevar function = new Function()function.__proto__ === Function.prototype //true// 另外，所有函数都是由 Function 构造出来的，所以Number.__proto__ === Function.prototype // 因为 Number 是函数，是 Function 的实例Object.__proto__ === Function.prototype // 因为 Object 是函数，是 Function 的实例Function.__proto__ === Function.prototye // 因为 Function 是函数，是 Function 的实例！","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"JS数据类型转换","slug":"JS数据类型转换","date":"2019-05-22T02:12:52.000Z","updated":"2019-05-22T02:40:51.946Z","comments":true,"path":"2019/05/22/JS数据类型转换/","link":"","permalink":"http://yoursite.com/2019/05/22/JS数据类型转换/","excerpt":"","text":"JS数据类型转换1.any to string 使用toString() 使用String()转换 和空字符串相加+&#39;&#39; 2.any to boolean 使用Boolean()转换 !!a 六个falsy值 false null 0 NaN undefined &#39;&#39; 对象object转换为boolean都为true 3.string to number 使用Number()转换 parseInt() 和 parseFloat() &#39;1&#39;-0 +&#39;1&#39; 4.JS内存图解4.1概述 初始类型的值如string、boolean、number存在Stack栈内存中，而object将Heap堆内存的地址存在Stack栈内存中。 4.2常见考题 遇到上述题目，可以先画内存图解，但是要注意 a.x = a = {n:2};是先确定a的内存地址再进行赋值的 4.3GC垃圾回收的简单理解如果一个对象没有被引用，它就是垃圾，可以被回收，可以画出内存图解方便理解。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"JS数据类型","slug":"JS数据类型","date":"2019-05-21T10:28:00.000Z","updated":"2019-05-21T13:30:15.497Z","comments":true,"path":"2019/05/21/JS数据类型/","link":"","permalink":"http://yoursite.com/2019/05/21/JS数据类型/","excerpt":"","text":"JS数据类型1.数据类型概述JS的数据类型共有七种： number(数值)：整数和小数（比如1和3.14） string(字符串)：文本（比如 hello world） boolean(布尔值)：true和false object(对象)：各种值的集合 undefined：表示“未定义”或者不存在 null：表示空值 symbol：es6新增 number、string、boolean这三种类型合称为原始类型的值，即是最基本的数据类型，不能再细分了。而object被称为合成类型的值，即是各种值的集合。至于undefined和null可以看成两个特殊的值。 2.null 和 undefined2.1概述null与undefined都可以表示“没有”，含义非常相似。将一个变量赋值为undefined或null，老实说，语法效果几乎没区别。在if语句中，它们都会被自动转为false，相等运算符（==）甚至直接报告两者相等。 123456789101112if (!undefined) &#123; console.log('undefined is false');&#125;// undefined is falseif (!null) &#123; console.log('null is false');&#125;// null is falseundefined == null// true 2.2用法和含义当你声明一个对象而又不想立即赋值时，可以将对象设为null，表示空值；而当你声明一个原始类型的值而又不想立即赋值时，可以用undefined。 3.boolean如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为false，其他值都视为true。 undefined null false 0 NaN &quot;&quot;或&#39;&#39;（空字符串） 4.number4.1整数和浮点数JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。 11 === 1.0 // true 这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数，然后再进行运算。 由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。 123456780.1 + 0.2 === 0.3// false0.3 / 0.1// 2.9999999999999996(0.3 - 0.2) === (0.2 - 0.1)// false 4.2数值范围根据标准，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则 JavaScript 能够表示的数值范围为21024到2-1023（开区间），超出这个范围的数无法表示。 如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回Infinity。 1Math.pow(2, 1024) // Infinity 如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回0。 1Math.pow(2, -1075) // 0 4.3进制JavaScript 对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。 十进制：没有前导0的数值。 八进制：有前缀0o或0O的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。 十六进制：有前缀0x或0X的数值。 二进制：有前缀0b或0B的数值。 4.4NaN4.4.1含义NaN是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。 15 - 'x' // NaN 上面代码运行时，会自动将字符串x转为数值，但是由于x不是数值，所以最后得到结果为NaN，表示它是“非数字”（NaN）。 另外，一些数学函数的运算结果会出现NaN。 123Math.acos(2) // NaNMath.log(-1) // NaNMath.sqrt(-1) // NaN 0除以0也会得到NaN。 10 / 0 // NaN 需要注意的是，NaN不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于Number，使用typeof运算符可以看得很清楚。 1typeof NaN // 'number' 4.4.2运算规则NaN不等于任何值，包括它本身。 1NaN === NaN // false 数组的indexOf方法内部使用的是严格相等运算符，所以该方法对NaN不成立。 1[NaN].indexOf(NaN) // -1 NaN在布尔运算时被当作false。 1Boolean(NaN) // false NaN与任何数（包括它自己）的运算，得到的都是NaN。 1234NaN + 32 // NaNNaN - 32 // NaNNaN * 32 // NaNNaN / 32 // NaN 4.5parseInt()4.5.1基本用法parseInt方法用于将字符串转为整数。 1parseInt('123') // 123 如果字符串头部有空格，空格会被自动去除。 1parseInt(' 81') // 81 如果parseInt的参数不是字符串，则会先转为字符串再转换。 123parseInt(1.23) // 1// 等同于parseInt('1.23') // 1 字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。 12345parseInt('8a') // 8parseInt('12**') // 12parseInt('12.34') // 12parseInt('15e2') // 15parseInt('15px') // 15 上面代码中，parseInt的参数都是字符串，结果只返回字符串头部可以转为数字的部分。 如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN。 12345parseInt('abc') // NaNparseInt('.3') // NaNparseInt('') // NaNparseInt('+') // NaNparseInt('+1') // 1 所以，parseInt的返回值只有两种可能，要么是一个十进制整数，要么是NaN。 如果字符串以0x或0X开头，parseInt会将其按照十六进制数解析。 1parseInt('0x10') // 16 如果字符串以0开头，将其按照10进制解析。 1parseInt('011') // 11 对于那些会自动转为科学计数法的数字，parseInt会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。 1234567parseInt(1000000000000000000000.5) // 1// 等同于parseInt('1e+21') // 1parseInt(0.0000008) // 8// 等同于parseInt('8e-7') // 8 4.5.2进制转换parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。默认情况下，parseInt的第二个参数为10，即默认是十进制转十进制。 123parseInt('1000') // 1000// 等同于parseInt('1000', 10) // 1000 下面是转换指定进制的数的例子。 123parseInt('1000', 2) // 8parseInt('1000', 6) // 216parseInt('1000', 8) // 512 上面代码中，二进制、六进制、八进制的1000，分别等于十进制的8、216和512。这意味着，可以用parseInt方法进行进制的转换。 如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回NaN。如果第二个参数是0、undefined和null，则直接忽略。 12345parseInt('10', 37) // NaNparseInt('10', 1) // NaNparseInt('10', 0) // 10parseInt('10', null) // 10parseInt('10', undefined) // 10 如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。如果最高位无法转换，则直接返回NaN。 12parseInt('1546', 2) // 1parseInt('546', 2) // NaN 上面代码中，对于二进制来说，1是有意义的字符，5、4、6都是无意义的字符，所以第一行返回1，第二行返回NaN。 前面说过，如果parseInt的第一个参数不是字符串，会被先转为字符串。这会导致一些令人意外的结果。 12345678910parseInt(0x11, 36) // 43parseInt(0x11, 2) // 1// 等同于parseInt(String(0x11), 36)parseInt(String(0x11), 2)// 等同于parseInt('17', 36)parseInt('17', 2) 上面代码中，十六进制的0x11会被先转为十进制的17，再转为字符串。然后，再用36进制或二进制解读字符串17，最后返回结果43和1。 这种处理方式，对于八进制的前缀0，尤其需要注意。 1234567parseInt(011, 2) // NaN// 等同于parseInt(String(011), 2)// 等同于parseInt(String(9), 2) 上面代码中，第一行的011会被先转为字符串9，因为9不是二进制的有效字符，所以返回NaN。如果直接计算parseInt(&#39;011&#39;, 2)，011则是会被当作二进制处理，返回3。 JavaScript 不再允许将带有前缀0的数字视为八进制数，而是要求忽略这个0。但是，为了保证兼容性，大部分浏览器并没有部署这一条规定。 4.6 parseFloat()parseFloat方法用于将一个字符串转为浮点数。 1parseFloat('3.14') // 3.14 如果字符串符合科学计数法，则会进行相应的转换。 12parseFloat('314e-2') // 3.14parseFloat('0.0314E+2') // 3.14 如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。 1parseFloat('3.14more non-digit characters') // 3.14 parseFloat方法会自动过滤字符串前导的空格。 1parseFloat('\\t\\v\\r12.34\\n ') // 12.34 如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回NaN。 123parseFloat([]) // NaNparseFloat('FF2') // NaNparseFloat('') // NaN 上面代码中，尤其值得注意，parseFloat会将空字符串转为NaN。 这些特点使得parseFloat的转换结果不同于Number函数。 1234567891011parseFloat(true) // NaNNumber(true) // 1parseFloat(null) // NaNNumber(null) // 0parseFloat('') // NaNNumber('') // 0parseFloat('123.45#') // 123.45Number('123.45#') // NaN 4.6 isNaN()isNaN方法可以用来判断一个值是否为NaN。 12isNaN(NaN) // trueisNaN(123) // false 但是，isNaN只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成NaN，所以最后返回true，这一点要特别引起注意。也就是说，isNaN为true的值，有可能不是NaN，而是一个字符串。 123isNaN('Hello') // true// 相当于isNaN(Number('Hello')) // true 出于同样的原因，对于对象和数组，isNaN也返回true。 1234567isNaN(&#123;&#125;) // true// 等同于isNaN(Number(&#123;&#125;)) // trueisNaN(['xzy']) // true// 等同于isNaN(Number(['xzy'])) // true 但是，对于空数组和只有一个数值成员的数组，isNaN返回false。 123isNaN([]) // falseisNaN([123]) // falseisNaN(['123']) // false 上面代码之所以返回false，原因是这些数组能被Number函数转成数值，请参见《数据类型转换》一章。 因此，使用isNaN之前，最好判断一下数据类型。 123function myIsNaN(value) &#123; return typeof value === 'number' &amp;&amp; isNaN(value);&#125; 判断NaN更可靠的方法是，利用NaN为唯一不等于自身的值的这个特点，进行判断。 123function myIsNaN(value) &#123; return value !== value;&#125; 5.string5.1概述字符串默认只能写在一行内，分成多行将会报错。 1234&apos;abc&apos;// SyntaxError: Unexpected token ILLEGAL 上面代码将一个字符串分成三行，JavaScript 就会报错。 如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。 1234567var longString = 'Long \\long \\long \\string';longString// \"Long long long string\" 上面代码表示，加了反斜杠以后，原来写在一行的字符串，可以分成多行书写。但是，输出的时候还是单行，效果与写在同一行完全一样。注意，反斜杠的后面必须是换行符，而不能有其他字符（比如空格），否则会报错。 连接运算符（+）可以连接多个单行字符串，将长字符串拆成多行书写，输出的时候也是单行。 1234var longString = 'Long ' + 'long ' + 'long ' + 'string'; es6中，可以使用反引号： 123var longString = `a b c` 5.2字符串与数组字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。 1234567var s = 'hello';s[0] // \"h\"s[1] // \"e\"s[4] // \"o\"// 直接对字符串使用方括号运算符'hello'[1] // \"e\" 如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回undefined。 123'abc'[3] // undefined'abc'[-1] // undefined'abc'['x'] // undefined 但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。 12345678910var s = 'hello';delete s[0];s // \"hello\"s[1] = 'a';s // \"hello\"s[5] = '!';s // \"hello\" 上面代码表示，字符串内部的单个字符无法改变和增删，这些操作会默默地失败。 length属性返回字符串的长度，该属性也是无法改变的。 12345678var s = 'hello';s.length // 5s.length = 3;s.length // 5s.length = 7;s.length // 5 上面代码表示字符串的length属性无法改变，但是不会报错。 5.3字符集JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。 JavaScript 不仅以 Unicode 储存字符，还允许直接在程序中使用 Unicode 码点表示字符，即将字符写成\\uxxxx的形式，其中xxxx代表该字符的 Unicode 码点。比如，\\u00A9代表版权符号。 12var s = '\\u00A9';s // \"©\" 解析代码的时候，JavaScript 会自动识别一个字符是字面形式表示，还是 Unicode 形式表示。输出给用户的时候，所有字符都会转成字面形式。 12var f\\u006F\\u006F = 'abc';foo // \"abc\" 上面代码中，第一行的变量名foo是 Unicode 形式表示，第二行是字面形式表示。JavaScript 会自动识别。 我们还需要知道，每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存。也就是说，JavaScript 的单位字符长度固定为16位长度，即2个字节。 但是，UTF-16 有两种长度：对于码点在U+0000到U+FFFF之间的字符，长度为16位（即2个字节）；对于码点在U+10000到U+10FFFF之间的字符，长度为32位（即4个字节），而且前两个字节在0xD800到0xDBFF之间，后两个字节在0xDC00到0xDFFF之间。举例来说，码点U+1D306对应的字符为𝌆，它写成 UTF-16 就是0xD834 0xDF06。 JavaScript 对 UTF-16 的支持是不完整的，由于历史原因，只支持两字节的字符，不支持四字节的字符。这是因为 JavaScript 第一版发布的时候，Unicode 的码点只编到U+FFFF，因此两字节足够表示了。后来，Unicode 纳入的字符越来越多，出现了四字节的编码。但是，JavaScript 的标准此时已经定型了，统一将字符长度限制在两字节，导致无法识别四字节的字符。上一节的那个四字节字符𝌆，浏览器会正确识别这是一个字符，但是 JavaScript 无法识别，会认为这是两个字符。 1'𝌆'.length // 2 上面代码中，JavaScript 认为𝌆的长度为2，而不是1。 总结一下，对于码点在U+10000到U+10FFFF之间的字符，JavaScript 总是认为它们是两个字符（length属性为2）。所以处理的时候，必须把这一点考虑在内，也就是说，JavaScript 返回的字符串长度可能是不正确的。 5.4Base64转码有时，文本里面包含一些不可打印的符号，比如 ASCII 码0到31的符号都无法打印出来，这时可以使用 Base64 编码，将它们转成可以打印的字符。另一个场景是，有时需要以文本格式传递二进制数据，那么也可以使用 Base64 编码。 所谓 Base64 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、+和/这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。 JavaScript 原生提供两个 Base64 相关的方法。 btoa()：任意值转为 Base64 编码 atob()：Base64 编码转为原来的值 123var string = 'Hello World!';btoa(string) // \"SGVsbG8gV29ybGQh\"atob('SGVsbG8gV29ybGQh') // \"Hello World!\" 注意，这两个方法不适合非 ASCII 码的字符，会报错。 1btoa('你好') // 报错 要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。 12345678910function b64Encode(str) &#123; return btoa(encodeURIComponent(str));&#125;function b64Decode(str) &#123; return decodeURIComponent(atob(str));&#125;b64Encode('你好') // \"JUU0JUJEJUEwJUU1JUE1JUJE\"b64Decode('JUU0JUJEJUEwJUU1JUE1JUJE') // \"你好\" 6.object6.1属性的查看查看一个对象本身的所有属性，可以使用Object.keys方法。 1234567var obj = &#123; key1: 1, key2: 2&#125;;Object.keys(obj);// ['key1', 'key2'] 6.2属性的删除：delete 命令delete命令用于删除对象的属性，删除成功后返回true。 123456var obj = &#123; p: 1 &#125;;Object.keys(obj) // [\"p\"]delete obj.p // trueobj.p // undefinedObject.keys(obj) // [] 上面代码中，delete命令删除对象obj的p属性。删除后，再读取p属性就会返回undefined，而且Object.keys方法的返回值也不再包括该属性。 注意，删除一个不存在的属性，delete不报错，而且返回true。 12var obj = &#123;&#125;;delete obj.p // true 上面代码中，对象obj并没有p属性，但是delete命令照样返回true。因此，不能根据delete命令的结果，认定某个属性是存在的。 只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。 1234567var obj = Object.defineProperty(&#123;&#125;, 'p', &#123; value: 123, configurable: false&#125;);obj.p // 123delete obj.p // false 上面代码之中，对象obj的p属性是不能删除的，所以delete命令返回false（关于Object.defineProperty方法的介绍，请看《标准库》的 Object 对象一章）。 另外，需要注意的是，delete命令只能删除对象本身的属性，无法删除继承的属性（关于继承参见《面向对象编程》章节）。 123var obj = &#123;&#125;;delete obj.toString // trueobj.toString // function toString() &#123; [native code] &#125; 上面代码中，toString是对象obj继承的属性，虽然delete命令返回true，但该属性并没有被删除，依然存在。这个例子还说明，即使delete返回true，该属性依然可能读取到值。 6.3属性是否存在：in 运算符in运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true，否则返回false。它的左边是一个字符串，表示属性名，右边是一个对象。 123var obj = &#123; p: 1 &#125;;'p' in obj // true'toString' in obj // true in运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。就像上面代码中，对象obj本身并没有toString属性，但是in运算符会返回true，因为这个属性是继承的。 这时，可以使用对象的hasOwnProperty方法判断一下，是否为对象自身的属性。 1234var obj = &#123;&#125;;if ('toString' in obj) &#123; console.log(obj.hasOwnProperty('toString')) // false&#125; 6.4属性的遍历：for…in 循环for...in循环用来遍历一个对象的全部属性。 123456789101112var obj = &#123;a: 1, b: 2, c: 3&#125;;for (var i in obj) &#123; console.log('键名：', i); console.log('键值：', obj[i]);&#125;// 键名： a// 键值： 1// 键名： b// 键值： 2// 键名： c// 键值： 3 for...in循环有两个使用注意点。 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。 它不仅遍历对象自身的属性，还遍历继承的属性。 举例来说，对象都继承了toString属性，但是for...in循环不会遍历到这个属性。 12345678var obj = &#123;&#125;;// toString 属性是存在的obj.toString // toString() &#123; [native code] &#125;for (var p in obj) &#123; console.log(p);&#125; // 没有任何输出 上面代码中，对象obj继承了toString属性，该属性不会被for...in循环遍历到，因为它默认是“不可遍历”的。关于对象属性的可遍历性，参见《标准库》章节中 Object 一章的介绍。 如果继承的属性是可遍历的，那么就会被for...in循环遍历到。但是，一般情况下，都是只想遍历对象自身的属性，所以使用for...in的时候，应该结合使用hasOwnProperty方法，在循环内部判断一下，某个属性是否为对象自身的属性。 12345678var person = &#123; name: '老张' &#125;;for (var key in person) &#123; if (person.hasOwnProperty(key)) &#123; console.log(key); &#125;&#125;// name 6.5with 语句with语句的格式如下： 123with (对象) &#123; 语句;&#125; 它的作用是操作同一个对象的多个属性时，提供一些书写的方便。 1234567891011121314151617181920212223// 例一var obj = &#123; p1: 1, p2: 2,&#125;;with (obj) &#123; p1 = 4; p2 = 5;&#125;// 等同于obj.p1 = 4;obj.p2 = 5;// 例二with (document.links[0])&#123; console.log(href); console.log(title); console.log(style);&#125;// 等同于console.log(document.links[0].href);console.log(document.links[0].title);console.log(document.links[0].style); 注意，如果with区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。 12345678var obj = &#123;&#125;;with (obj) &#123; p1 = 4; p2 = 5;&#125;obj.p1 // undefinedp1 // 4 上面代码中，对象obj并没有p1属性，对p1赋值等于创造了一个全局变量p1。正确的写法应该是，先定义对象obj的属性p1，然后在with区块内操作它。 这是因为with区块没有改变作用域，它的内部依然是当前作用域。这造成了with语句的一个很大的弊病，就是绑定对象不明确。 123with (obj) &#123; console.log(x);&#125; 单纯从上面的代码块，根本无法判断x到底是全局变量，还是对象obj的一个属性。这非常不利于代码的除错和模块化，编译器也无法对这段代码进行优化，只能留到运行时判断，这就拖慢了运行速度。因此，建议不要使用with语句，可以考虑用一个临时变量代替with。 1234567with(obj1.obj2.obj3) &#123; console.log(p1 + p2);&#125;// 可以写成var temp = obj1.obj2.obj3;console.log(temp.p1 + temp.p2); 7.参考资料阮一峰博客https://wangdoc.com/javascript/types/","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"BFC","slug":"BFC","date":"2019-05-19T07:25:25.000Z","updated":"2019-05-19T07:43:33.349Z","comments":true,"path":"2019/05/19/BFC/","link":"","permalink":"http://yoursite.com/2019/05/19/BFC/","excerpt":"","text":"BFC（blocking formatting context）BFC的描述CSS规范中对 BFC 的描述 9.4.1 块格式化上下文 浮动，绝对定位元素，非块盒的块容器（例如，inline-blocks，table-cells和table-captions）和’overflow’不为’visible’的块盒会为它们的内容建立一个新的块格式化上下文 在一个块格式化上下文中，盒在竖直方向一个接一个地放置，从包含块的顶部开始。两个兄弟盒之间的竖直距离由’margin’属性决定。同一个块格式化上下文中的相邻块级盒之间的竖直margin会合并 在一个块格式化上下文中，每个盒的left外边（left outer edge）挨着包含块的left边（对于从右向左的格式化，right边挨着）。即使存在浮动（尽管一个盒的行盒可能会因为浮动收缩），这也成立。除非该盒建立了一个新的块格式化上下文（这种情况下，该盒自身可能会因为浮动变窄） MDN 对 BFC 的描述 一个块格式化上下文（block formatting context） 是Web页面的可视化CSS渲染出的一部分。它是块级盒布局出现的区域，也是浮动层元素进行交互的区域。 一个块格式化上下文由以下之一创建： 根元素或其它包含它的元素 浮动元素 (元素的 float 不是 none) 绝对定位元素 (元素具有 position 为 absolute 或 fixed) 内联块 (元素具有 display: inline-block) 表格单元格 (元素具有 display: table-cell，HTML表格单元格默认属性) 表格标题 (元素具有 display: table-caption, HTML表格标题默认属性) 具有overflow 且值不是 visible 的块元素， display: flow-root column-span: all 应当总是会创建一个新的格式化上下文，即便具有 column-span: all 的元素并不被包裹在一个多列容器中。 一个块格式化上下文包括创建它的元素内部所有内容，除了被包含于创建新的块级格式化上下文的后代元素内的元素。 块格式化上下文对于定位 (参见 float) 与清除浮动 (参见 clear) 很重要。定位和清除浮动的样式规则只适用于处于同一块格式化上下文内的元素。浮动不会影响其它块格式化上下文中元素的布局，并且清除浮动只能清除同一块格式化上下文中在它前面的元素的浮动。 张鑫旭对 BFC 的描述http://www.zhangxinxu.com/wordpress/2015/02/css-deep-understand-flow-bfc-column-two-auto-layout/ BFC全称”Block Formatting Context”, 中文为“块级格式化上下文”。啪啦啪啦特性什么的，一言难尽，大家可以自行去查找，我这里不详述，免得乱了主次，总之，记住这么一句话：BFC元素特性表现原则就是，内部子元素再怎么翻江倒海，翻云覆雨都不会影响外部的元素。所以，避免margin穿透啊，清除浮动什么的也好理解了。 看完这些你是不是已经迷糊了，想知道BFC到底是什么 先思考一个问题： 请问：什么是色情？ 联邦最高法院大法官斯图尔特更有一句名言 我不知道什么是色情，不过，我看了之后，就能知道 I know it when I see it 类似地： 我不知道什么是 BFC 但是你写出样式，我就知道这是不是 BFC BFC 就是这样的东西（堆叠上下文也是） 它没有定义 它只有特性/功能 BFC的功能功能1：利用BFC包住内部浮动元素原始场景 给父元素加上overflow:hidden或者display:flow-root后触发bfc 功能2：利用BFC让兄弟元素划清界限原始场景 给littleBro加上overflow:hidden或者display:flow-root 触发bfc BFC的创建 浮动（float） 绝对定位（position:absolute） 非块盒的块容器：例如inline-block,table-cells,table-captions overflow不为visible的块盒 display:flow-root 新增属性专门用于触发BFC，兼容性较差","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"flex布局","slug":"flex布局","date":"2019-05-19T06:53:59.000Z","updated":"2019-05-19T07:21:12.931Z","comments":true,"path":"2019/05/19/flex布局/","link":"","permalink":"http://yoursite.com/2019/05/19/flex布局/","excerpt":"","text":"flex布局1、flex布局的特点 flex布局与方向无关 空间自动分配，自动对齐 简单的线性布局 2、flex container和item flex container属性介绍 flex-direction：用来调整主轴和反转 flex-wrap: 是否换行 flex-flow 上面两个属性的简写 justify-content:用来调整主轴对齐方向 align-items:用来调整侧轴对齐方向 align-content:多行多列时调整对齐方向 flex item属性介绍 flex-grow:按比例分配空间 flex-shrink:按比例收缩空间 flex-basis:默认大小 flex: 上面三个属性的简写 order:顺序，用来代替双飞翼布局 align-self:自身对齐方式，优先级高于container的对齐方式","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"移动端页面","slug":"移动端页面","date":"2019-05-19T06:36:11.000Z","updated":"2019-05-19T06:51:24.913Z","comments":true,"path":"2019/05/19/移动端页面/","link":"","permalink":"http://yoursite.com/2019/05/19/移动端页面/","excerpt":"","text":"移动端页面（响应式）的做法1、学会用媒体查询media query红极一时的bootstrap将响应式布局都归功于媒体查询media query，所以一定要学会媒体查询的使用。下面介绍一些基础写法: 1、判断页面最大宽度： 12345@media(max-width:800px)&#123; body&#123; background:red; &#125;&#125; 2、判断页面宽度在某一区间时： 12345@media(min-width:321px) and (max-width:800px)&#123; body&#123; background:red; &#125;&#125; 2、学会要设计图巧妇难为无米之炊，没有各个分辨率下的设计图还是别做响应式了吧 3、学会隐藏元素尽量不要用js直接操作元素属性display:none的方式隐藏，而是改变元素的class样式。 4、手机端要加一个 meta&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; 5、手机端的交互方式不一样 没有 hover 有 touch 事件 没有 resize 没有滚动条","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"层叠顺序","slug":"层叠顺序和层叠上下文","date":"2019-05-19T05:35:25.000Z","updated":"2019-05-19T06:15:53.075Z","comments":true,"path":"2019/05/19/层叠顺序和层叠上下文/","link":"","permalink":"http://yoursite.com/2019/05/19/层叠顺序和层叠上下文/","excerpt":"","text":"层叠顺序和层叠上下文默认情况下，网页内容是没有偏移角的垂直视觉呈现，当内容发生层叠的时候，一定会有一个前后的层叠顺序产生，而要理解网页中元素是如何“论资排辈”的，就需要深入理解CSS中的层叠上下文和层叠顺序。 一、层叠上下文的概念层叠上下文（Stacking context）是HTML中的一个三维的概念，如果一个元素含有层叠上下文，那么这个元素在Z轴上就要”高人一等“。这个Z轴指的就是眼睛与屏幕这条看不见的垂直线。 二、层叠水平的概念层叠水平（Stacking level）决定了同一个层叠上下文中元素在z轴上的显示顺序。所有的元素都有层叠水平，包括层叠上下文元素。对于普通元素的层叠水平优先由层叠上下文决定，层叠水平的比较只有在当前层叠上下文元素中才有意义。 不要把层叠水平和CSS的z-index属性混为一谈。没错，某些情况下z-index确实可以影响层叠水平，但是，只限于定位元素以及flex盒子的孩子元素；而层叠水平所有的元素都存在。 三、了解层叠顺序 下面这两个是层叠领域的黄金准则。当元素发生层叠的时候，其覆盖关系遵循下面2个准则： 谁大谁上：当具有明显的层叠水平标示的时候，如识别的z-index值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个。 后来居上：当元素的层叠水平一致、层叠顺序相同的时候，在DOM流中处于后面的元素会覆盖前面的元素。 在CSS和HTML领域，只要元素发生了重叠，都离不开上面这两个黄金准则。 四、层叠上下文的形成可以理解为层叠作用域。跟 BFC 一样，我们只知道一些属性会触发层叠上下文，但并不知道层叠上下文是什么。 根元素 (HTML), z-index 值不为 “auto”的 绝对/相对定位， 一个 z-index 值不为 “auto”的 flex 项目 (flex item)，即：父元素 display: flex|inline-flex， opacity 属性值小于 1 的元素（参考 the specification for opacity）， transform 属性值不为 “none”的元素， mix-blend-mode 属性值不为 “normal”的元素， filter值不为“none”的元素， perspective值不为“none”的元素， isolation 属性被设置为 “isolate”的元素， position: fixed 在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值（参考 这篇文章） -webkit-overflow-scrolling 属性被设置 “touch”的元素","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"VSCode前端开发插件配置","slug":"VSCode前端开发插件配置","date":"2019-05-19T02:38:13.000Z","updated":"2019-05-19T02:40:52.985Z","comments":true,"path":"2019/05/19/VSCode前端开发插件配置/","link":"","permalink":"http://yoursite.com/2019/05/19/VSCode前端开发插件配置/","excerpt":"","text":"VSCode前端开发插件配置作为前端开发人员，拥有一款适合自己的编辑器无异于如虎添翼，之前经常使用SumlimeText的我首次试用VSCode就有一种心动的感觉。VSCode这款免费的编辑器颜值够高，合理配置插件后也可以媲美WebStorm这种硬核的编辑器，那么你还有什么理由拒绝它呢。 每每上手新的编辑器，我都会根据自己的开发习惯把它调较到理想状态，加上熟悉编辑器各种特性，这个过程通常需要几周的时间。接下来，我就从外观配置、风格检查、编码效率、功能增强等 4 方面来侃侃怎么配置 VSCode 来提高工作幸福感。 外观配置作为前端开发者，外观当然是最先考虑的部分，从配置的角度，无非是配色、图标、字体等，俗话说萝卜白菜各有所爱，我目前的配色、图标字体如下： 配色：One Dark Pro，在VSCode Extensions中搜索One Dark Pro安装即可 图标：Material Icon Theme，给不同类型的文件配置不同的图标，非常直观； 字体：Fira Code，自从发现并开始使用 Fira Code，我就再也没多看自其它字体一眼，字体如果比较优雅，尤其是对数学运算符的处理 风格检查 保障优秀一致的代码风格是一个程序员的高尚品质，如果编辑器在编码时实时给出反馈，对开发者个人而言才是最高效的，在提交时做强制检查只是从团队的视角保证编码风格的规范性和一致性。前端工程师会书写的代码无非是：HTML、CSS、Javascript、Markdown、TypeScript、JSON，对应的 Lint 工具就显而易见： ESLint：插件式架构，有多种主流的编码风格规则集可供选择，典型的有 Airbnb、Google 等 StyleLint，同样插件式架构的样式检查工具 TSLint：编写TypeScript你会想用到它的 MarkdownLint：Markdown 如果不合法，可能在某些场合导致解析器异常，因为 Markdown 有好几套标准，在不同标准间部分语法支持可能是不兼容的； 有了风格检查，自然就会产生按配置好的风格规则做文件格式化的需求，另外推荐一款好用的格式化工具：Prettier，实际上已经是代码格式化的工具标准，支持格式化几乎所有的前端代码，并且类似于 EditorConfig 支持用文件来配置格式规则； 编码效率说到编码效率，当你感觉击键的速率已经赶不上自己的思维时就需要在编码时设置适当的快捷键，组合使用智能建议、代码片段、自动补全来达到速度的最大化。重点说说代码片段和自动补全两个效率提升利器。代码片段英文叫做 Snippets，市面上主流的编辑器也都支持，其基本思想就是把常见的代码模式抽出来，通过 2~3 个键就能展开 N 行代码，代码片段的积累一方面是根据个人习惯，另一方面是学习社区里面积累出来的好的编码模式，如果觉得不适合你，可以改（找个现有的插件依葫芦画瓢） 常用的代码片段插件 HTML Snippets，各种 HTML 标签片段，如果你 Emmet 玩的熟，完全可以忽略这个 Javascript (ES6) Code Snippets，常用的类声明、ES 模块声明、CMD 模块导入等，支持的缩写不下 20 种 Javascript Patterns Snippets，常见的编码模式，比如 IIFE；自动补全自动补全本质上和代码片段类似，不过是在特殊场合下以你的键入做为启发式信息提供最有可能要输入的建议 常用的自动补全工具 Auto Close Tag，适用于 JSX、Vue、HTML，在打开标签并且键入 &lt;/ 的时候，能自动补全要闭合的标签； Auto Rename Tag，适用于 JSX、Vue、HTML，在修改标签名时，能在你修改开始（结束）标签的时候修改对应的结束（开始）标签，帮你减少 50% 的击键 Path Intellisense，文件路径补全，在你用任何方式引入文件系统中的路径时提供智能提示和自动完成；NPM Intellisense，NPM 依赖补全，在你引入任何 node_modules 里面的依赖包时提供智能提示和自动完成 IntelliSense for CSS class names，CSS 类名补全，会自动扫描整个项目里面的 CSS 类名并在你输入类名时做智能提示 Emmet，以前叫做 Zen Coding，我发现后，也是爱不释手，可以把类 CSS 选择符的字符串展开成 HTML 标签，VSCode 已经内置，官方介绍文档参见，你需要做的就是熟悉他的语法，并勤加练习 TODO Highlight维护时间稍长的代码仓库免不了会有各种 TODO、FIXME、HACK 之类的标记，TODO Highlight 能够帮我们把这些关键词高亮出来，在你翻阅代码时非常醒目，就像是在大声提醒你尽快把他解决掉。支持自定义配置需要高亮的关键词，实际使用比较坑的地方是，TODO、FIXME 之类的后面必须加上冒号，否则无法高亮。 功能增强在效率提升方面除了上面的代码片段、自动补全之外，我还安装了下面几个插件，方便快速的浏览和理解代码，并且在不同项目之间切换。 Color Highlight，识别代码中的颜色，包括各种颜色格式； Bracket Pair Colorizer，识别代码中的各种括号，并且标记上不同的颜色，方便你扫视到匹配的括号，在括号使用非常多的情况下能环节眼部压力，编辑器快捷键固然好用，但是在临近嵌套多的情况下却有些力不从心； Project Manager，项目管理，让我们方便的在命令面板中切换项目文件夹，当然，你也可以直接打开包含多个项目的父级文件夹，但这样可能会让 VSCode 变慢； 不同设备同步VSCode配置Settings SyncSettings Sync 基于 Gist 实现 VSCode 用户配置、快捷键配置、已安装插件列表等的备份和恢复功能，配置过程有详细精确的操作步骤文档。生成的备份 Gist 默认是私密的，如果你想设置为共享的，也可以一键切换。","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"VSCode","slug":"VSCode","permalink":"http://yoursite.com/tags/VSCode/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"CSS进阶笔记","slug":"CSS进阶笔记","date":"2019-05-19T00:49:29.000Z","updated":"2019-05-19T05:11:12.031Z","comments":true,"path":"2019/05/19/CSS进阶笔记/","link":"","permalink":"http://yoursite.com/2019/05/19/CSS进阶笔记/","excerpt":"","text":"标准流Normal Flow水平居中块级元素 宽度固定： 1234div&#123; margin-left: auto; margin-right: auto;&#125; 宽度不固定： 1234div&#123; margin-left: 20px; margin-right: 20px;&#125; 内联元素设置内联元素的父元素text-align属性： 123.parent&#123; text-align: center;&#125; 垂直居中不兼容IE时，可以使用flex布局简单实现： 1234div&#123; display: flex; align-items: center;&#125; 兼容IE时，可以使用table布局 文字溢出省略 单行文字溢出省略： 12345p&#123; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;&#125; 多行文字溢出省略： 123456p&#123; display: -webkit-box; -webkit-line-clamp: 2; /*在这里设置行数*/ -webkit-box-orient: vertical; overflow: hidden;&#125; 盒模型盒模型分类：W3C标准盒模型和IE盒模型 盒模型分为W3C标准盒模型和IE盒模型。在ie8+浏览器中使用哪个盒模型可以由box-sizing(CSS新增的属性)控制，默认值为content-box，即标准盒模型；如果将box-sizing设为border-box则用的是IE盒模型。如果在ie6,7,8中DOCTYPE缺失会触发IE模式。在当前W3C标准中盒模型是可以通过box-sizing自由的进行切换的。 W3C标准盒模型：属性width和height只包含content,不包含padding和border IE盒模型：属性width,height包含border和padding，指的是content+padding+border。 调试方法要学会使用border进行CSS的调试，可以说不会border调试方法就不要写CSS啦~.~ 实现一个宽度自适应的1:1的div123div&#123; padding-top: 100%;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"CSS学习笔记","slug":"CSS学习笔记","date":"2019-05-09T12:21:25.000Z","updated":"2019-05-19T00:53:38.247Z","comments":true,"path":"2019/05/09/CSS学习笔记/","link":"","permalink":"http://yoursite.com/2019/05/09/CSS学习笔记/","excerpt":"","text":"CSS学习笔记导航栏的CSS简单实现利用css可以将垂直展示的ul,ol列表转变为水平展示的导航栏html代码： 123456789&lt;ul class=&quot;clearfix&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;关于&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;技能&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;作品&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;博客&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;日历&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;联系方式&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;其他&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; css代码1234567891011clearfix::after&#123; content:&quot;&quot;; display:block; clear:both;&#125;li &#123;float: left;margin-left: 17px;margin-right: 17px;&#125; 可以记住口诀：子元素加float属性，父元素使用clearfix 高度是由什么决定的块级元素块级元素相对简单，高度是由其内部文档流高度总和决定的。那么什么是文档流呢？文档流即是文档内的元素流动方向。内联元素是从左往右流动的，当宽度不足时，自动换行。块级元素是从上往下流动的。 内联元素内联元素相对复杂，其中font-size的问题最为经典，font-size的值指字体最低的部分到字体最高部分的距离，而为了展示效果，默认行高根据不同字体有所差异。我们也可以通过line-height属性来设置建议行高，然后只有在字体大小较小时，line-height才生效。 css画一个三角形html代码：1&lt;div class=&quot;triangle&quot;&gt;&lt;/div&gt; css代码：123456.triangle&#123; width:0; border:20px solid transparent; border-top-width:0; border-left-color:blue;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"HTTP常用标签","slug":"HTTP常用标签","date":"2019-05-08T15:03:57.000Z","updated":"2019-05-19T00:53:44.332Z","comments":true,"path":"2019/05/08/HTTP常用标签/","link":"","permalink":"http://yoursite.com/2019/05/08/HTTP常用标签/","excerpt":"","text":"HTML常用标签HTML 常用标签iframe标签HTML内联框架元素 iframe表示嵌套的浏览上下文，有效地将另一个HTML页面嵌入到当前页面中。 属性 frameborder 取值为1时（默认值），告诉浏览器在当前iframe与其他iframe之间绘制边框，取0时则无需绘制此边框。默认的比较丑，一般取0。 height 以CSS像素格式指定frame的高度。 width 以CSS像素格式或以百分比格式指定frame的宽度。 name 嵌入的浏览上下文（框架）的名称。该名称可以用作标签a，form的target属性值，或者标签input，button的formtaget属性值。 src 嵌套页面的URL地址。使用遵守同源策略的 ‘about:blank’ 来嵌套空白页。 a标签HTML 元素 (或锚元素) 可以创建一个到其他网页、文件、同一页面内的位置、电子邮件地址或任何其他URL的超链接。 属性 download 此属性指示浏览器下载URL或者文件而不是导航到它，因此将提示用户将其保存为本地文件。此属性仅使用于**同源URL**, 如果不是同源(同域), 将会导航到该URL, 例如: &lt;a href=&quot;http://127.0.0.1:8080/index.html&quot; download=&quot;index&quot;&gt;下载&lt;/a&gt; 会下载同源的一个index.html &lt;a href=&quot;http://qq.com&quot; download=&quot;qq&quot;&gt;下载&lt;/a&gt;, download无效, 将导航到qq.com target: 该属性指定在何处显示链接的资源。 取值为标签（tab），窗口（window），或框架（iframe）等浏览上下文的名称或其他关键词。 target=&quot;_self&quot;: 当前页面加载, 如果没有指定此属性的话, 该值是默认值. target=&quot;_blank&quot;: 新窗口打开 target=&quot;_parent&quot;: 会加载到当前页面的父页面, 如果没有父页面,则等同于_self targe=&quot;_top&quot;: 会加载到最顶层页面, 祖先级页面, 当index1.html包含index2.html, index2.html包含index3.html, 则index3.html中的跳转则会加载到index1.html上 href 包含超链接指向的URL或URL片段。 &lt;a href=&quot;qq.com&quot;&gt;QQ&lt;/a&gt;:,点击QQ不会跳转到qq.com 会把qq.com当成文件, 不是以.com为后缀就是网址,也可以是文件 &lt;a href=&quot;//qq.com&quot;&gt;QQ&lt;/a&gt;, 不写协议的时候, 无协议绝对地址, 默认是当前页面协议, 是file协议, 就跳转file://qq.com, 是HTTP协议, 就跳转到http://qq.com &lt;a href=&quot;xxx.html&quot;&gt;xxx&lt;/a&gt;, 相对路径, 路径只会以目录为参考, 如果在index.html中跳转, 并不会以index.html为前缀index.html/xxx.html, 会显示xxx.html &lt;a href=&quot;#1&quot;&gt;1ink&lt;/a&gt;, 写锚点, 会自动加到后面, 不会发起请求, index.html#1, 虽然不会发起请求,但是页面会有变化. &lt;a href=&quot;?name=xxx&quot;&gt;query&lt;/a&gt;, 写参数, 会自动加到后面, 并发起GET请求, index.html?name=xxx &lt;a href=&quot;javascript: alert(1)&quot;&gt;js&lt;/a&gt;, 伪协议, 会执行js代码. &lt;a href=&quot;javascript:;&quot;&gt;js&lt;/a&gt;, 伪协议, 使其标签点击而不做任何动作，可以实现某些奇葩需求 &lt;a href=&quot;&quot;&gt;blank&lt;/a&gt;, 什么也不写, 页面会刷新, 跳转到了自己. name 和iframe配合使用 form标签HTML元素 表示了文档中的一个区域，这个区域包含有交互控制元件，用来向web服务器提交信息。 a标签和form标签都是跳转, 区别就是a标签发起的是GET请求, form标签发起的是POST请求. 属性 action提交(POST)数据所到的地方.action=&quot;users&quot;, 就是提交到users, 一个处理这个form信息的程序所在的URL.method浏览器使用这种指定方式来提交 form, GET一般不用写, 如果是GET, 提交的数据会被作为查询参数, 并不会放到第四部分作为formdata, POST会把提交的数据放到formdata里, 如果要给POST加查询参数, 可以通过给URL加查询参数?query=xxx target和a标签相同nameHTML5中，一个文档中的多个form当中，name必须唯一而不仅仅是一个空字符串. 也可以与iframe标签配合使用. 如果form标签没有提交按钮, 则无法提交, html里只有form标签能提交数据，提交按钮可以是有一个 input type=submit 的元素或者有一个 button 元素，button 的 type 属性为空 input标签HTML input 元素用于为基于Web的表单创建交互式控件，以便接受来自用户的数据。使用input标签提交数据, 必须有name属性. 属性 type 要呈现的控件类型 type=&quot;button&quot;: 普通按钮 type=&quot;checkbox&quot;: 复选框。必须使用 value 属性定义此控件被提交时的值 color： 用于指定颜色的控件。 date：用于输入日期的控件（年，月，日，不包括时间）。 datetime：基于 UTC 时区的日期时间输入控件（时，分，秒及几分之一秒）。 datetime-local：用于输入日期时间控件，不包含时区。 email：用于编辑 e-mail 的字段。 合适的时候可以使用 file：此控件可以让用户选择文件。使用 accept 属性可以定义控件可以选择的文件类型。 hidden：不显示在页面上的控件，但它的值会被提交到服务器。 image：图片提交按钮。必须使用 src 属性定义图片的来源及使用 alt 定义替代文本。还可以使用 height 和 width 属性以像素为单位定义图片的大小。 month：用于输入年月的控件，不带时区。 number:用于输入浮点数的控件。 password：一个值被遮盖的单行文本字段。使用 maxlength 指定可以输入的值的最大长度 。 radio：单选按钮。必须使用 value 属性定义此控件被提交时的值。使用checked 必须指示控件是否缺省被选择。在同一个”单选按钮组“中，所有单选按钮的 name 属性使用同一个值； 一个单选按钮组中是，同一时间只有一个单选按钮可以被选择。 reset：用于将表单所内容设置为缺省值的按钮。 search：用于输入搜索字符串的单行文本字段。换行会被从输入的值中自动移除。 submit：用于提交表单的按钮。 tel： 用于输入电话号码的控件；换行会被自动从输入的值中移除A，但不会执行其他语法。可以使用属性，比如 pattern 和 maxlength 来约束控件输入的值。恰当的时候，可以应用 text：单行字段；换行会将自动从输入的值中移除。 time：用于输入不含时区的时间控件。 url：用于编辑URL的字段。 The user may enter a blank or invalid address. 换行会被自动从输入值中移队。可以使用如：pattern 和 maxlength 样的属性来约束输入的值。 恰当的时候使可以应用 week：用于输入一个由星期-年组成的日期，日期不包括时区。 autocomplete这个属性表示这个控件的值是否可被浏览器自动填充。如果type属性的值是hidden、checkbox、radio、file，或为按钮类型（button、submit、reset、image），则本属性被忽略。 autofocus这个布尔属性允许您指定的表单控件在页面加载时具有焦点（自动获得焦点），除非用户将其覆盖，例如通过键入不同的控件。文档中只有一个表单元素可以具有autofocus属性，它是一个布尔值。 如果type属性设置为隐藏则不能应用（即您不能自动获得焦点的属性设置为隐藏的控件）。 disabled这个布尔属性表示此表单控件不可用。 特别是在禁用的控件中， click 事件 [将不会被分发]。 并且，禁用的控件的值在提交表单时也不会被提交。如果 type 属性为 hidden，此属性将被忽略。 小Tips:可以使用将input元素嵌入到label元素中达到点击文本时自动将焦点移动到input上元素上 button标签HTML button 元素表示一个可点击的按钮，可以用在表单或文档其它需要使用简单标准按钮的地方 input和button区别: 是否是空元素, button有子元素, input没有 属性 typebutton的类型 submit: 此按钮将表单数据提交给服务器。如果未指定属性，或者属性动态更改为空值或无效值，则此值为默认值。 reset: 此按钮重置所有组件为初始值。 button: 此按钮没有默认行为。它可以有与元素事件相关的客户端脚本，当事件出现时可触发。 menu: 此按钮打开一个由指定元素进行定义的弹出菜单。 namebutton的名称，与表单数据一起提交。 valuebutton的初始值。它定义的值与表单数据的提交按钮相关联。当表单中的数据被提交时，这个值便以参数的形式被递送至服务器。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"HTTP请求和响应初探","slug":"HTTP请求和响应初探","date":"2019-05-04T13:23:27.000Z","updated":"2019-05-19T00:53:49.797Z","comments":true,"path":"2019/05/04/HTTP请求和响应初探/","link":"","permalink":"http://yoursite.com/2019/05/04/HTTP请求和响应初探/","excerpt":"","text":"HTTP请求和响应初探HTTP协议作为前端开发者必须掌握的知识点，它的作用就是知道浏览器和服务器如何进行沟通。下面我们就分别用命令行和Chrome开发者工具来初步探索HTTP请求和响应的内容。 HTTP请求使用命令行curl命令请求示例在命令行中输入如下命令： 1curl -s -v -H \"User: xxx\" -- \"https://www.baidu.com\" 简单分析一下我们创造的命令，curl用来创造一个请求，-s是-silent的缩写，表示不显示进度条和错误信息，-v是-verbose的缩写，常用于debug时候查找详细信息，-H “User: xxx”表示自定义一个header。接下来我们关注一下命令行显示的请求内容为： 12345GET / HTTP/1.1Host: www.baidu.comUser-Agent: curl/7.63.0Accept: */*User: xxx 然后我们把请求的方式变成POST，在命令行中输入如下命令： 1curl -X POST -s -v -H \"User: xxx\" -- \"https://www.baidu.com\" 得到的请求内容为： 12345POST / HTTP/1.1Host: www.baidu.comUser-Agent: curl/7.63.0Accept: */*User: xxx ​ 我们继续在POST请求的基础上加入-d data内容： 1curl -X POST -d \"1234567890\" -s -v -H \"User: xxx\" -- \"https://www.baidu.com\" 得到的请求内容为： 123456789POST / HTTP/1.1Host: www.baidu.comUser-Agent: curl/7.63.0Accept: */*User: xxxContent-Length: 10Content-Type: application/x-www-form-urlencoded1234567890 ​ ` 使用Chrome开发者工具查看请求内容 打开chrome,按F12，点击Network 输入网址https://www.baidu.com/ 选中第一个响应 查看 Request Headers，点击「view source」，会看到如下图所示的请求内容 请求的格式我们已经通过curl命令和Chorme开发者工具两种方式看到了HTTP的请求内容，下面我们总结一下HTTP请求的格式 1234567891 动词 路径 协议/版本2 Key1: value12 Key2: value22 Key3: value32 Content-Type: application/x-www-form-urlencoded2 Host: www.baidu.com2 User-Agent: curl/7.54.03 4 要上传的数据 请求最多包含四部分，最少包含三部分。（也就是说第四部分可以为空） 第三部分永远都是一个回车（\\n） 动词有 GET POST PUT PATCH DELETE HEAD OPTIONS 等 这里的路径包括「查询参数」，但不包括「锚点」 如果你没有写路径，那么路径默认为 / 第 2 部分中的 Content-Type 标注了第 4 部分的格式 第3部分只是一个空行，目的是为了区分第2部分和第4部分要上传的数据 HTTP响应请求了之后，应该都能得到一个响应，除非断网了，或者服务器宕机了。 响应示例上面三个请求示例，前两个请求对应的响应分别为 1234567891011121314151617181920212223242526HTTP/1.1 200 OKAccept-Ranges: bytesCache-Control: private, no-cache, no-store, proxy-revalidate, no-transformConnection: Keep-AliveContent-Length: 2443Content-Type: text/htmlDate: Tue, 10 Oct 2017 09:14:05 GMTEtag: &quot;5886041d-98b&quot;Last-Modified: Mon, 23 Jan 2017 13:24:45 GMTPragma: no-cacheServer: bfe/1.0.8.18Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt; 后面太长，省略了……HTTP/1.1 302 FoundConnection: Keep-AliveContent-Length: 17931Content-Type: text/htmlDate: Tue, 10 Oct 2017 09:19:47 GMTEtag: &quot;54d9749e-460b&quot;Server: bfe/1.0.8.18&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt; 后面太长，省略了…… GET 请求和 POST 请求对应的响应可以一样，也可以不一样 响应的第四部分可以很长很长很长 响应的格式12345671 协议/版本号 状态码 状态解释2 Key1: value12 Key2: value22 Content-Length: 179312 Content-Type: text/html34 要下载的内容 状态码要背，是服务器对浏览器说的话 1xx 不常用 2xx 表示成功 3xx 表示滚吧 4xx 表示你丫错了 5xx 表示好吧，我错了 状态解释没什么用 第 2 部分中的 Content-Type 标注了第 4 部分的格式 第 2 部分中的 Content-Type 遵循 MIME 规范 用 Chrome 查看响应 打开 Network 输入网址 选中第一个响应 查看 Response Headers，点击「view source」 你会看到响应的前两部分 查看 Response 或者 Preview，你会看到响应的第 4 部分","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]}]}