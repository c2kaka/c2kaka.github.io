{"meta":{"title":"欧阳帆","subtitle":null,"description":"kaka的博客","author":"kaka","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"用公式理解JS原型链","slug":"用公式理解JS原型链","date":"2019-05-22T08:31:27.000Z","updated":"2019-05-22T08:44:18.593Z","comments":true,"path":"2019/05/22/用公式理解JS原型链/","link":"","permalink":"http://yoursite.com/2019/05/22/用公式理解JS原型链/","excerpt":"","text":"用公式理解JS原型链重要公式 123456789101112131415161718var 对象 = new 构造函数();对象.__proto__ === 构造函数.protoType //true//推论var number = new Number();number.__proto__ === Number.protoType //truevar object = new Object()object.__proto__ === Object.prototype //truevar function = new Function()function.__proto__ === Function.prototype //true// 另外，所有函数都是由 Function 构造出来的，所以Number.__proto__ === Function.prototype // 因为 Number 是函数，是 Function 的实例Object.__proto__ === Function.prototype // 因为 Object 是函数，是 Function 的实例Function.__proto__ === Function.prototye // 因为 Function 是函数，是 Function 的实例！","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"JS数据类型转换","slug":"JS数据类型转换","date":"2019-05-22T02:12:52.000Z","updated":"2019-05-22T02:40:51.946Z","comments":true,"path":"2019/05/22/JS数据类型转换/","link":"","permalink":"http://yoursite.com/2019/05/22/JS数据类型转换/","excerpt":"","text":"JS数据类型转换1.any to string 使用toString() 使用String()转换 和空字符串相加+&#39;&#39; 2.any to boolean 使用Boolean()转换 !!a 六个falsy值 false null 0 NaN undefined &#39;&#39; 对象object转换为boolean都为true 3.string to number 使用Number()转换 parseInt() 和 parseFloat() &#39;1&#39;-0 +&#39;1&#39; 4.JS内存图解4.1概述 初始类型的值如string、boolean、number存在Stack栈内存中，而object将Heap堆内存的地址存在Stack栈内存中。 4.2常见考题 遇到上述题目，可以先画内存图解，但是要注意 a.x = a = {n:2};是先确定a的内存地址再进行赋值的 4.3GC垃圾回收的简单理解如果一个对象没有被引用，它就是垃圾，可以被回收，可以画出内存图解方便理解。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"JS数据类型","slug":"JS数据类型","date":"2019-05-21T10:28:00.000Z","updated":"2019-05-21T13:30:15.497Z","comments":true,"path":"2019/05/21/JS数据类型/","link":"","permalink":"http://yoursite.com/2019/05/21/JS数据类型/","excerpt":"","text":"JS数据类型1.数据类型概述JS的数据类型共有七种： number(数值)：整数和小数（比如1和3.14） string(字符串)：文本（比如 hello world） boolean(布尔值)：true和false object(对象)：各种值的集合 undefined：表示“未定义”或者不存在 null：表示空值 symbol：es6新增 number、string、boolean这三种类型合称为原始类型的值，即是最基本的数据类型，不能再细分了。而object被称为合成类型的值，即是各种值的集合。至于undefined和null可以看成两个特殊的值。 2.null 和 undefined2.1概述null与undefined都可以表示“没有”，含义非常相似。将一个变量赋值为undefined或null，老实说，语法效果几乎没区别。在if语句中，它们都会被自动转为false，相等运算符（==）甚至直接报告两者相等。 123456789101112if (!undefined) &#123; console.log('undefined is false');&#125;// undefined is falseif (!null) &#123; console.log('null is false');&#125;// null is falseundefined == null// true 2.2用法和含义当你声明一个对象而又不想立即赋值时，可以将对象设为null，表示空值；而当你声明一个原始类型的值而又不想立即赋值时，可以用undefined。 3.boolean如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为false，其他值都视为true。 undefined null false 0 NaN &quot;&quot;或&#39;&#39;（空字符串） 4.number4.1整数和浮点数JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。 11 === 1.0 // true 这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数，然后再进行运算。 由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。 123456780.1 + 0.2 === 0.3// false0.3 / 0.1// 2.9999999999999996(0.3 - 0.2) === (0.2 - 0.1)// false 4.2数值范围根据标准，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则 JavaScript 能够表示的数值范围为21024到2-1023（开区间），超出这个范围的数无法表示。 如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回Infinity。 1Math.pow(2, 1024) // Infinity 如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回0。 1Math.pow(2, -1075) // 0 4.3进制JavaScript 对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。 十进制：没有前导0的数值。 八进制：有前缀0o或0O的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。 十六进制：有前缀0x或0X的数值。 二进制：有前缀0b或0B的数值。 4.4NaN4.4.1含义NaN是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。 15 - 'x' // NaN 上面代码运行时，会自动将字符串x转为数值，但是由于x不是数值，所以最后得到结果为NaN，表示它是“非数字”（NaN）。 另外，一些数学函数的运算结果会出现NaN。 123Math.acos(2) // NaNMath.log(-1) // NaNMath.sqrt(-1) // NaN 0除以0也会得到NaN。 10 / 0 // NaN 需要注意的是，NaN不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于Number，使用typeof运算符可以看得很清楚。 1typeof NaN // 'number' 4.4.2运算规则NaN不等于任何值，包括它本身。 1NaN === NaN // false 数组的indexOf方法内部使用的是严格相等运算符，所以该方法对NaN不成立。 1[NaN].indexOf(NaN) // -1 NaN在布尔运算时被当作false。 1Boolean(NaN) // false NaN与任何数（包括它自己）的运算，得到的都是NaN。 1234NaN + 32 // NaNNaN - 32 // NaNNaN * 32 // NaNNaN / 32 // NaN 4.5parseInt()4.5.1基本用法parseInt方法用于将字符串转为整数。 1parseInt('123') // 123 如果字符串头部有空格，空格会被自动去除。 1parseInt(' 81') // 81 如果parseInt的参数不是字符串，则会先转为字符串再转换。 123parseInt(1.23) // 1// 等同于parseInt('1.23') // 1 字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。 12345parseInt('8a') // 8parseInt('12**') // 12parseInt('12.34') // 12parseInt('15e2') // 15parseInt('15px') // 15 上面代码中，parseInt的参数都是字符串，结果只返回字符串头部可以转为数字的部分。 如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN。 12345parseInt('abc') // NaNparseInt('.3') // NaNparseInt('') // NaNparseInt('+') // NaNparseInt('+1') // 1 所以，parseInt的返回值只有两种可能，要么是一个十进制整数，要么是NaN。 如果字符串以0x或0X开头，parseInt会将其按照十六进制数解析。 1parseInt('0x10') // 16 如果字符串以0开头，将其按照10进制解析。 1parseInt('011') // 11 对于那些会自动转为科学计数法的数字，parseInt会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。 1234567parseInt(1000000000000000000000.5) // 1// 等同于parseInt('1e+21') // 1parseInt(0.0000008) // 8// 等同于parseInt('8e-7') // 8 4.5.2进制转换parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。默认情况下，parseInt的第二个参数为10，即默认是十进制转十进制。 123parseInt('1000') // 1000// 等同于parseInt('1000', 10) // 1000 下面是转换指定进制的数的例子。 123parseInt('1000', 2) // 8parseInt('1000', 6) // 216parseInt('1000', 8) // 512 上面代码中，二进制、六进制、八进制的1000，分别等于十进制的8、216和512。这意味着，可以用parseInt方法进行进制的转换。 如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回NaN。如果第二个参数是0、undefined和null，则直接忽略。 12345parseInt('10', 37) // NaNparseInt('10', 1) // NaNparseInt('10', 0) // 10parseInt('10', null) // 10parseInt('10', undefined) // 10 如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。如果最高位无法转换，则直接返回NaN。 12parseInt('1546', 2) // 1parseInt('546', 2) // NaN 上面代码中，对于二进制来说，1是有意义的字符，5、4、6都是无意义的字符，所以第一行返回1，第二行返回NaN。 前面说过，如果parseInt的第一个参数不是字符串，会被先转为字符串。这会导致一些令人意外的结果。 12345678910parseInt(0x11, 36) // 43parseInt(0x11, 2) // 1// 等同于parseInt(String(0x11), 36)parseInt(String(0x11), 2)// 等同于parseInt('17', 36)parseInt('17', 2) 上面代码中，十六进制的0x11会被先转为十进制的17，再转为字符串。然后，再用36进制或二进制解读字符串17，最后返回结果43和1。 这种处理方式，对于八进制的前缀0，尤其需要注意。 1234567parseInt(011, 2) // NaN// 等同于parseInt(String(011), 2)// 等同于parseInt(String(9), 2) 上面代码中，第一行的011会被先转为字符串9，因为9不是二进制的有效字符，所以返回NaN。如果直接计算parseInt(&#39;011&#39;, 2)，011则是会被当作二进制处理，返回3。 JavaScript 不再允许将带有前缀0的数字视为八进制数，而是要求忽略这个0。但是，为了保证兼容性，大部分浏览器并没有部署这一条规定。 4.6 parseFloat()parseFloat方法用于将一个字符串转为浮点数。 1parseFloat('3.14') // 3.14 如果字符串符合科学计数法，则会进行相应的转换。 12parseFloat('314e-2') // 3.14parseFloat('0.0314E+2') // 3.14 如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。 1parseFloat('3.14more non-digit characters') // 3.14 parseFloat方法会自动过滤字符串前导的空格。 1parseFloat('\\t\\v\\r12.34\\n ') // 12.34 如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回NaN。 123parseFloat([]) // NaNparseFloat('FF2') // NaNparseFloat('') // NaN 上面代码中，尤其值得注意，parseFloat会将空字符串转为NaN。 这些特点使得parseFloat的转换结果不同于Number函数。 1234567891011parseFloat(true) // NaNNumber(true) // 1parseFloat(null) // NaNNumber(null) // 0parseFloat('') // NaNNumber('') // 0parseFloat('123.45#') // 123.45Number('123.45#') // NaN 4.6 isNaN()isNaN方法可以用来判断一个值是否为NaN。 12isNaN(NaN) // trueisNaN(123) // false 但是，isNaN只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成NaN，所以最后返回true，这一点要特别引起注意。也就是说，isNaN为true的值，有可能不是NaN，而是一个字符串。 123isNaN('Hello') // true// 相当于isNaN(Number('Hello')) // true 出于同样的原因，对于对象和数组，isNaN也返回true。 1234567isNaN(&#123;&#125;) // true// 等同于isNaN(Number(&#123;&#125;)) // trueisNaN(['xzy']) // true// 等同于isNaN(Number(['xzy'])) // true 但是，对于空数组和只有一个数值成员的数组，isNaN返回false。 123isNaN([]) // falseisNaN([123]) // falseisNaN(['123']) // false 上面代码之所以返回false，原因是这些数组能被Number函数转成数值，请参见《数据类型转换》一章。 因此，使用isNaN之前，最好判断一下数据类型。 123function myIsNaN(value) &#123; return typeof value === 'number' &amp;&amp; isNaN(value);&#125; 判断NaN更可靠的方法是，利用NaN为唯一不等于自身的值的这个特点，进行判断。 123function myIsNaN(value) &#123; return value !== value;&#125; 5.string5.1概述字符串默认只能写在一行内，分成多行将会报错。 1234&apos;abc&apos;// SyntaxError: Unexpected token ILLEGAL 上面代码将一个字符串分成三行，JavaScript 就会报错。 如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。 1234567var longString = 'Long \\long \\long \\string';longString// \"Long long long string\" 上面代码表示，加了反斜杠以后，原来写在一行的字符串，可以分成多行书写。但是，输出的时候还是单行，效果与写在同一行完全一样。注意，反斜杠的后面必须是换行符，而不能有其他字符（比如空格），否则会报错。 连接运算符（+）可以连接多个单行字符串，将长字符串拆成多行书写，输出的时候也是单行。 1234var longString = 'Long ' + 'long ' + 'long ' + 'string'; es6中，可以使用反引号： 123var longString = `a b c` 5.2字符串与数组字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。 1234567var s = 'hello';s[0] // \"h\"s[1] // \"e\"s[4] // \"o\"// 直接对字符串使用方括号运算符'hello'[1] // \"e\" 如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回undefined。 123'abc'[3] // undefined'abc'[-1] // undefined'abc'['x'] // undefined 但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。 12345678910var s = 'hello';delete s[0];s // \"hello\"s[1] = 'a';s // \"hello\"s[5] = '!';s // \"hello\" 上面代码表示，字符串内部的单个字符无法改变和增删，这些操作会默默地失败。 length属性返回字符串的长度，该属性也是无法改变的。 12345678var s = 'hello';s.length // 5s.length = 3;s.length // 5s.length = 7;s.length // 5 上面代码表示字符串的length属性无法改变，但是不会报错。 5.3字符集JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。 JavaScript 不仅以 Unicode 储存字符，还允许直接在程序中使用 Unicode 码点表示字符，即将字符写成\\uxxxx的形式，其中xxxx代表该字符的 Unicode 码点。比如，\\u00A9代表版权符号。 12var s = '\\u00A9';s // \"©\" 解析代码的时候，JavaScript 会自动识别一个字符是字面形式表示，还是 Unicode 形式表示。输出给用户的时候，所有字符都会转成字面形式。 12var f\\u006F\\u006F = 'abc';foo // \"abc\" 上面代码中，第一行的变量名foo是 Unicode 形式表示，第二行是字面形式表示。JavaScript 会自动识别。 我们还需要知道，每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存。也就是说，JavaScript 的单位字符长度固定为16位长度，即2个字节。 但是，UTF-16 有两种长度：对于码点在U+0000到U+FFFF之间的字符，长度为16位（即2个字节）；对于码点在U+10000到U+10FFFF之间的字符，长度为32位（即4个字节），而且前两个字节在0xD800到0xDBFF之间，后两个字节在0xDC00到0xDFFF之间。举例来说，码点U+1D306对应的字符为𝌆，它写成 UTF-16 就是0xD834 0xDF06。 JavaScript 对 UTF-16 的支持是不完整的，由于历史原因，只支持两字节的字符，不支持四字节的字符。这是因为 JavaScript 第一版发布的时候，Unicode 的码点只编到U+FFFF，因此两字节足够表示了。后来，Unicode 纳入的字符越来越多，出现了四字节的编码。但是，JavaScript 的标准此时已经定型了，统一将字符长度限制在两字节，导致无法识别四字节的字符。上一节的那个四字节字符𝌆，浏览器会正确识别这是一个字符，但是 JavaScript 无法识别，会认为这是两个字符。 1'𝌆'.length // 2 上面代码中，JavaScript 认为𝌆的长度为2，而不是1。 总结一下，对于码点在U+10000到U+10FFFF之间的字符，JavaScript 总是认为它们是两个字符（length属性为2）。所以处理的时候，必须把这一点考虑在内，也就是说，JavaScript 返回的字符串长度可能是不正确的。 5.4Base64转码有时，文本里面包含一些不可打印的符号，比如 ASCII 码0到31的符号都无法打印出来，这时可以使用 Base64 编码，将它们转成可以打印的字符。另一个场景是，有时需要以文本格式传递二进制数据，那么也可以使用 Base64 编码。 所谓 Base64 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、+和/这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。 JavaScript 原生提供两个 Base64 相关的方法。 btoa()：任意值转为 Base64 编码 atob()：Base64 编码转为原来的值 123var string = 'Hello World!';btoa(string) // \"SGVsbG8gV29ybGQh\"atob('SGVsbG8gV29ybGQh') // \"Hello World!\" 注意，这两个方法不适合非 ASCII 码的字符，会报错。 1btoa('你好') // 报错 要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。 12345678910function b64Encode(str) &#123; return btoa(encodeURIComponent(str));&#125;function b64Decode(str) &#123; return decodeURIComponent(atob(str));&#125;b64Encode('你好') // \"JUU0JUJEJUEwJUU1JUE1JUJE\"b64Decode('JUU0JUJEJUEwJUU1JUE1JUJE') // \"你好\" 6.object6.1属性的查看查看一个对象本身的所有属性，可以使用Object.keys方法。 1234567var obj = &#123; key1: 1, key2: 2&#125;;Object.keys(obj);// ['key1', 'key2'] 6.2属性的删除：delete 命令delete命令用于删除对象的属性，删除成功后返回true。 123456var obj = &#123; p: 1 &#125;;Object.keys(obj) // [\"p\"]delete obj.p // trueobj.p // undefinedObject.keys(obj) // [] 上面代码中，delete命令删除对象obj的p属性。删除后，再读取p属性就会返回undefined，而且Object.keys方法的返回值也不再包括该属性。 注意，删除一个不存在的属性，delete不报错，而且返回true。 12var obj = &#123;&#125;;delete obj.p // true 上面代码中，对象obj并没有p属性，但是delete命令照样返回true。因此，不能根据delete命令的结果，认定某个属性是存在的。 只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。 1234567var obj = Object.defineProperty(&#123;&#125;, 'p', &#123; value: 123, configurable: false&#125;);obj.p // 123delete obj.p // false 上面代码之中，对象obj的p属性是不能删除的，所以delete命令返回false（关于Object.defineProperty方法的介绍，请看《标准库》的 Object 对象一章）。 另外，需要注意的是，delete命令只能删除对象本身的属性，无法删除继承的属性（关于继承参见《面向对象编程》章节）。 123var obj = &#123;&#125;;delete obj.toString // trueobj.toString // function toString() &#123; [native code] &#125; 上面代码中，toString是对象obj继承的属性，虽然delete命令返回true，但该属性并没有被删除，依然存在。这个例子还说明，即使delete返回true，该属性依然可能读取到值。 6.3属性是否存在：in 运算符in运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true，否则返回false。它的左边是一个字符串，表示属性名，右边是一个对象。 123var obj = &#123; p: 1 &#125;;'p' in obj // true'toString' in obj // true in运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。就像上面代码中，对象obj本身并没有toString属性，但是in运算符会返回true，因为这个属性是继承的。 这时，可以使用对象的hasOwnProperty方法判断一下，是否为对象自身的属性。 1234var obj = &#123;&#125;;if ('toString' in obj) &#123; console.log(obj.hasOwnProperty('toString')) // false&#125; 6.4属性的遍历：for…in 循环for...in循环用来遍历一个对象的全部属性。 123456789101112var obj = &#123;a: 1, b: 2, c: 3&#125;;for (var i in obj) &#123; console.log('键名：', i); console.log('键值：', obj[i]);&#125;// 键名： a// 键值： 1// 键名： b// 键值： 2// 键名： c// 键值： 3 for...in循环有两个使用注意点。 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。 它不仅遍历对象自身的属性，还遍历继承的属性。 举例来说，对象都继承了toString属性，但是for...in循环不会遍历到这个属性。 12345678var obj = &#123;&#125;;// toString 属性是存在的obj.toString // toString() &#123; [native code] &#125;for (var p in obj) &#123; console.log(p);&#125; // 没有任何输出 上面代码中，对象obj继承了toString属性，该属性不会被for...in循环遍历到，因为它默认是“不可遍历”的。关于对象属性的可遍历性，参见《标准库》章节中 Object 一章的介绍。 如果继承的属性是可遍历的，那么就会被for...in循环遍历到。但是，一般情况下，都是只想遍历对象自身的属性，所以使用for...in的时候，应该结合使用hasOwnProperty方法，在循环内部判断一下，某个属性是否为对象自身的属性。 12345678var person = &#123; name: '老张' &#125;;for (var key in person) &#123; if (person.hasOwnProperty(key)) &#123; console.log(key); &#125;&#125;// name 6.5with 语句with语句的格式如下： 123with (对象) &#123; 语句;&#125; 它的作用是操作同一个对象的多个属性时，提供一些书写的方便。 1234567891011121314151617181920212223// 例一var obj = &#123; p1: 1, p2: 2,&#125;;with (obj) &#123; p1 = 4; p2 = 5;&#125;// 等同于obj.p1 = 4;obj.p2 = 5;// 例二with (document.links[0])&#123; console.log(href); console.log(title); console.log(style);&#125;// 等同于console.log(document.links[0].href);console.log(document.links[0].title);console.log(document.links[0].style); 注意，如果with区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。 12345678var obj = &#123;&#125;;with (obj) &#123; p1 = 4; p2 = 5;&#125;obj.p1 // undefinedp1 // 4 上面代码中，对象obj并没有p1属性，对p1赋值等于创造了一个全局变量p1。正确的写法应该是，先定义对象obj的属性p1，然后在with区块内操作它。 这是因为with区块没有改变作用域，它的内部依然是当前作用域。这造成了with语句的一个很大的弊病，就是绑定对象不明确。 123with (obj) &#123; console.log(x);&#125; 单纯从上面的代码块，根本无法判断x到底是全局变量，还是对象obj的一个属性。这非常不利于代码的除错和模块化，编译器也无法对这段代码进行优化，只能留到运行时判断，这就拖慢了运行速度。因此，建议不要使用with语句，可以考虑用一个临时变量代替with。 1234567with(obj1.obj2.obj3) &#123; console.log(p1 + p2);&#125;// 可以写成var temp = obj1.obj2.obj3;console.log(temp.p1 + temp.p2); 7.参考资料阮一峰博客https://wangdoc.com/javascript/types/","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"BFC","slug":"BFC","date":"2019-05-19T07:25:25.000Z","updated":"2019-05-19T07:43:33.349Z","comments":true,"path":"2019/05/19/BFC/","link":"","permalink":"http://yoursite.com/2019/05/19/BFC/","excerpt":"","text":"BFC（blocking formatting context）BFC的描述CSS规范中对 BFC 的描述 9.4.1 块格式化上下文 浮动，绝对定位元素，非块盒的块容器（例如，inline-blocks，table-cells和table-captions）和’overflow’不为’visible’的块盒会为它们的内容建立一个新的块格式化上下文 在一个块格式化上下文中，盒在竖直方向一个接一个地放置，从包含块的顶部开始。两个兄弟盒之间的竖直距离由’margin’属性决定。同一个块格式化上下文中的相邻块级盒之间的竖直margin会合并 在一个块格式化上下文中，每个盒的left外边（left outer edge）挨着包含块的left边（对于从右向左的格式化，right边挨着）。即使存在浮动（尽管一个盒的行盒可能会因为浮动收缩），这也成立。除非该盒建立了一个新的块格式化上下文（这种情况下，该盒自身可能会因为浮动变窄） MDN 对 BFC 的描述 一个块格式化上下文（block formatting context） 是Web页面的可视化CSS渲染出的一部分。它是块级盒布局出现的区域，也是浮动层元素进行交互的区域。 一个块格式化上下文由以下之一创建： 根元素或其它包含它的元素 浮动元素 (元素的 float 不是 none) 绝对定位元素 (元素具有 position 为 absolute 或 fixed) 内联块 (元素具有 display: inline-block) 表格单元格 (元素具有 display: table-cell，HTML表格单元格默认属性) 表格标题 (元素具有 display: table-caption, HTML表格标题默认属性) 具有overflow 且值不是 visible 的块元素， display: flow-root column-span: all 应当总是会创建一个新的格式化上下文，即便具有 column-span: all 的元素并不被包裹在一个多列容器中。 一个块格式化上下文包括创建它的元素内部所有内容，除了被包含于创建新的块级格式化上下文的后代元素内的元素。 块格式化上下文对于定位 (参见 float) 与清除浮动 (参见 clear) 很重要。定位和清除浮动的样式规则只适用于处于同一块格式化上下文内的元素。浮动不会影响其它块格式化上下文中元素的布局，并且清除浮动只能清除同一块格式化上下文中在它前面的元素的浮动。 张鑫旭对 BFC 的描述http://www.zhangxinxu.com/wordpress/2015/02/css-deep-understand-flow-bfc-column-two-auto-layout/ BFC全称”Block Formatting Context”, 中文为“块级格式化上下文”。啪啦啪啦特性什么的，一言难尽，大家可以自行去查找，我这里不详述，免得乱了主次，总之，记住这么一句话：BFC元素特性表现原则就是，内部子元素再怎么翻江倒海，翻云覆雨都不会影响外部的元素。所以，避免margin穿透啊，清除浮动什么的也好理解了。 看完这些你是不是已经迷糊了，想知道BFC到底是什么 先思考一个问题： 请问：什么是色情？ 联邦最高法院大法官斯图尔特更有一句名言 我不知道什么是色情，不过，我看了之后，就能知道 I know it when I see it 类似地： 我不知道什么是 BFC 但是你写出样式，我就知道这是不是 BFC BFC 就是这样的东西（堆叠上下文也是） 它没有定义 它只有特性/功能 BFC的功能功能1：利用BFC包住内部浮动元素原始场景 给父元素加上overflow:hidden或者display:flow-root后触发bfc 功能2：利用BFC让兄弟元素划清界限原始场景 给littleBro加上overflow:hidden或者display:flow-root 触发bfc BFC的创建 浮动（float） 绝对定位（position:absolute） 非块盒的块容器：例如inline-block,table-cells,table-captions overflow不为visible的块盒 display:flow-root 新增属性专门用于触发BFC，兼容性较差","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"flex布局","slug":"flex布局","date":"2019-05-19T06:53:59.000Z","updated":"2019-05-19T07:21:12.931Z","comments":true,"path":"2019/05/19/flex布局/","link":"","permalink":"http://yoursite.com/2019/05/19/flex布局/","excerpt":"","text":"flex布局1、flex布局的特点 flex布局与方向无关 空间自动分配，自动对齐 简单的线性布局 2、flex container和item flex container属性介绍 flex-direction：用来调整主轴和反转 flex-wrap: 是否换行 flex-flow 上面两个属性的简写 justify-content:用来调整主轴对齐方向 align-items:用来调整侧轴对齐方向 align-content:多行多列时调整对齐方向 flex item属性介绍 flex-grow:按比例分配空间 flex-shrink:按比例收缩空间 flex-basis:默认大小 flex: 上面三个属性的简写 order:顺序，用来代替双飞翼布局 align-self:自身对齐方式，优先级高于container的对齐方式","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"移动端页面","slug":"移动端页面","date":"2019-05-19T06:36:11.000Z","updated":"2019-05-19T06:51:24.913Z","comments":true,"path":"2019/05/19/移动端页面/","link":"","permalink":"http://yoursite.com/2019/05/19/移动端页面/","excerpt":"","text":"移动端页面（响应式）的做法1、学会用媒体查询media query红极一时的bootstrap将响应式布局都归功于媒体查询media query，所以一定要学会媒体查询的使用。下面介绍一些基础写法: 1、判断页面最大宽度： 12345@media(max-width:800px)&#123; body&#123; background:red; &#125;&#125; 2、判断页面宽度在某一区间时： 12345@media(min-width:321px) and (max-width:800px)&#123; body&#123; background:red; &#125;&#125; 2、学会要设计图巧妇难为无米之炊，没有各个分辨率下的设计图还是别做响应式了吧 3、学会隐藏元素尽量不要用js直接操作元素属性display:none的方式隐藏，而是改变元素的class样式。 4、手机端要加一个 meta&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; 5、手机端的交互方式不一样 没有 hover 有 touch 事件 没有 resize 没有滚动条","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"层叠顺序","slug":"层叠顺序和层叠上下文","date":"2019-05-19T05:35:25.000Z","updated":"2019-05-19T06:15:53.075Z","comments":true,"path":"2019/05/19/层叠顺序和层叠上下文/","link":"","permalink":"http://yoursite.com/2019/05/19/层叠顺序和层叠上下文/","excerpt":"","text":"层叠顺序和层叠上下文默认情况下，网页内容是没有偏移角的垂直视觉呈现，当内容发生层叠的时候，一定会有一个前后的层叠顺序产生，而要理解网页中元素是如何“论资排辈”的，就需要深入理解CSS中的层叠上下文和层叠顺序。 一、层叠上下文的概念层叠上下文（Stacking context）是HTML中的一个三维的概念，如果一个元素含有层叠上下文，那么这个元素在Z轴上就要”高人一等“。这个Z轴指的就是眼睛与屏幕这条看不见的垂直线。 二、层叠水平的概念层叠水平（Stacking level）决定了同一个层叠上下文中元素在z轴上的显示顺序。所有的元素都有层叠水平，包括层叠上下文元素。对于普通元素的层叠水平优先由层叠上下文决定，层叠水平的比较只有在当前层叠上下文元素中才有意义。 不要把层叠水平和CSS的z-index属性混为一谈。没错，某些情况下z-index确实可以影响层叠水平，但是，只限于定位元素以及flex盒子的孩子元素；而层叠水平所有的元素都存在。 三、了解层叠顺序 下面这两个是层叠领域的黄金准则。当元素发生层叠的时候，其覆盖关系遵循下面2个准则： 谁大谁上：当具有明显的层叠水平标示的时候，如识别的z-index值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个。 后来居上：当元素的层叠水平一致、层叠顺序相同的时候，在DOM流中处于后面的元素会覆盖前面的元素。 在CSS和HTML领域，只要元素发生了重叠，都离不开上面这两个黄金准则。 四、层叠上下文的形成可以理解为层叠作用域。跟 BFC 一样，我们只知道一些属性会触发层叠上下文，但并不知道层叠上下文是什么。 根元素 (HTML), z-index 值不为 “auto”的 绝对/相对定位， 一个 z-index 值不为 “auto”的 flex 项目 (flex item)，即：父元素 display: flex|inline-flex， opacity 属性值小于 1 的元素（参考 the specification for opacity）， transform 属性值不为 “none”的元素， mix-blend-mode 属性值不为 “normal”的元素， filter值不为“none”的元素， perspective值不为“none”的元素， isolation 属性被设置为 “isolate”的元素， position: fixed 在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值（参考 这篇文章） -webkit-overflow-scrolling 属性被设置 “touch”的元素","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"VSCode前端开发插件配置","slug":"VSCode前端开发插件配置","date":"2019-05-19T02:38:13.000Z","updated":"2019-05-19T02:40:52.985Z","comments":true,"path":"2019/05/19/VSCode前端开发插件配置/","link":"","permalink":"http://yoursite.com/2019/05/19/VSCode前端开发插件配置/","excerpt":"","text":"VSCode前端开发插件配置作为前端开发人员，拥有一款适合自己的编辑器无异于如虎添翼，之前经常使用SumlimeText的我首次试用VSCode就有一种心动的感觉。VSCode这款免费的编辑器颜值够高，合理配置插件后也可以媲美WebStorm这种硬核的编辑器，那么你还有什么理由拒绝它呢。 每每上手新的编辑器，我都会根据自己的开发习惯把它调较到理想状态，加上熟悉编辑器各种特性，这个过程通常需要几周的时间。接下来，我就从外观配置、风格检查、编码效率、功能增强等 4 方面来侃侃怎么配置 VSCode 来提高工作幸福感。 外观配置作为前端开发者，外观当然是最先考虑的部分，从配置的角度，无非是配色、图标、字体等，俗话说萝卜白菜各有所爱，我目前的配色、图标字体如下： 配色：One Dark Pro，在VSCode Extensions中搜索One Dark Pro安装即可 图标：Material Icon Theme，给不同类型的文件配置不同的图标，非常直观； 字体：Fira Code，自从发现并开始使用 Fira Code，我就再也没多看自其它字体一眼，字体如果比较优雅，尤其是对数学运算符的处理 风格检查 保障优秀一致的代码风格是一个程序员的高尚品质，如果编辑器在编码时实时给出反馈，对开发者个人而言才是最高效的，在提交时做强制检查只是从团队的视角保证编码风格的规范性和一致性。前端工程师会书写的代码无非是：HTML、CSS、Javascript、Markdown、TypeScript、JSON，对应的 Lint 工具就显而易见： ESLint：插件式架构，有多种主流的编码风格规则集可供选择，典型的有 Airbnb、Google 等 StyleLint，同样插件式架构的样式检查工具 TSLint：编写TypeScript你会想用到它的 MarkdownLint：Markdown 如果不合法，可能在某些场合导致解析器异常，因为 Markdown 有好几套标准，在不同标准间部分语法支持可能是不兼容的； 有了风格检查，自然就会产生按配置好的风格规则做文件格式化的需求，另外推荐一款好用的格式化工具：Prettier，实际上已经是代码格式化的工具标准，支持格式化几乎所有的前端代码，并且类似于 EditorConfig 支持用文件来配置格式规则； 编码效率说到编码效率，当你感觉击键的速率已经赶不上自己的思维时就需要在编码时设置适当的快捷键，组合使用智能建议、代码片段、自动补全来达到速度的最大化。重点说说代码片段和自动补全两个效率提升利器。代码片段英文叫做 Snippets，市面上主流的编辑器也都支持，其基本思想就是把常见的代码模式抽出来，通过 2~3 个键就能展开 N 行代码，代码片段的积累一方面是根据个人习惯，另一方面是学习社区里面积累出来的好的编码模式，如果觉得不适合你，可以改（找个现有的插件依葫芦画瓢） 常用的代码片段插件 HTML Snippets，各种 HTML 标签片段，如果你 Emmet 玩的熟，完全可以忽略这个 Javascript (ES6) Code Snippets，常用的类声明、ES 模块声明、CMD 模块导入等，支持的缩写不下 20 种 Javascript Patterns Snippets，常见的编码模式，比如 IIFE；自动补全自动补全本质上和代码片段类似，不过是在特殊场合下以你的键入做为启发式信息提供最有可能要输入的建议 常用的自动补全工具 Auto Close Tag，适用于 JSX、Vue、HTML，在打开标签并且键入 &lt;/ 的时候，能自动补全要闭合的标签； Auto Rename Tag，适用于 JSX、Vue、HTML，在修改标签名时，能在你修改开始（结束）标签的时候修改对应的结束（开始）标签，帮你减少 50% 的击键 Path Intellisense，文件路径补全，在你用任何方式引入文件系统中的路径时提供智能提示和自动完成；NPM Intellisense，NPM 依赖补全，在你引入任何 node_modules 里面的依赖包时提供智能提示和自动完成 IntelliSense for CSS class names，CSS 类名补全，会自动扫描整个项目里面的 CSS 类名并在你输入类名时做智能提示 Emmet，以前叫做 Zen Coding，我发现后，也是爱不释手，可以把类 CSS 选择符的字符串展开成 HTML 标签，VSCode 已经内置，官方介绍文档参见，你需要做的就是熟悉他的语法，并勤加练习 TODO Highlight维护时间稍长的代码仓库免不了会有各种 TODO、FIXME、HACK 之类的标记，TODO Highlight 能够帮我们把这些关键词高亮出来，在你翻阅代码时非常醒目，就像是在大声提醒你尽快把他解决掉。支持自定义配置需要高亮的关键词，实际使用比较坑的地方是，TODO、FIXME 之类的后面必须加上冒号，否则无法高亮。 功能增强在效率提升方面除了上面的代码片段、自动补全之外，我还安装了下面几个插件，方便快速的浏览和理解代码，并且在不同项目之间切换。 Color Highlight，识别代码中的颜色，包括各种颜色格式； Bracket Pair Colorizer，识别代码中的各种括号，并且标记上不同的颜色，方便你扫视到匹配的括号，在括号使用非常多的情况下能环节眼部压力，编辑器快捷键固然好用，但是在临近嵌套多的情况下却有些力不从心； Project Manager，项目管理，让我们方便的在命令面板中切换项目文件夹，当然，你也可以直接打开包含多个项目的父级文件夹，但这样可能会让 VSCode 变慢； 不同设备同步VSCode配置Settings SyncSettings Sync 基于 Gist 实现 VSCode 用户配置、快捷键配置、已安装插件列表等的备份和恢复功能，配置过程有详细精确的操作步骤文档。生成的备份 Gist 默认是私密的，如果你想设置为共享的，也可以一键切换。","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"VSCode","slug":"VSCode","permalink":"http://yoursite.com/tags/VSCode/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"CSS进阶笔记","slug":"CSS进阶笔记","date":"2019-05-19T00:49:29.000Z","updated":"2019-05-19T05:11:12.031Z","comments":true,"path":"2019/05/19/CSS进阶笔记/","link":"","permalink":"http://yoursite.com/2019/05/19/CSS进阶笔记/","excerpt":"","text":"标准流Normal Flow水平居中块级元素 宽度固定： 1234div&#123; margin-left: auto; margin-right: auto;&#125; 宽度不固定： 1234div&#123; margin-left: 20px; margin-right: 20px;&#125; 内联元素设置内联元素的父元素text-align属性： 123.parent&#123; text-align: center;&#125; 垂直居中不兼容IE时，可以使用flex布局简单实现： 1234div&#123; display: flex; align-items: center;&#125; 兼容IE时，可以使用table布局 文字溢出省略 单行文字溢出省略： 12345p&#123; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;&#125; 多行文字溢出省略： 123456p&#123; display: -webkit-box; -webkit-line-clamp: 2; /*在这里设置行数*/ -webkit-box-orient: vertical; overflow: hidden;&#125; 盒模型盒模型分类：W3C标准盒模型和IE盒模型 盒模型分为W3C标准盒模型和IE盒模型。在ie8+浏览器中使用哪个盒模型可以由box-sizing(CSS新增的属性)控制，默认值为content-box，即标准盒模型；如果将box-sizing设为border-box则用的是IE盒模型。如果在ie6,7,8中DOCTYPE缺失会触发IE模式。在当前W3C标准中盒模型是可以通过box-sizing自由的进行切换的。 W3C标准盒模型：属性width和height只包含content,不包含padding和border IE盒模型：属性width,height包含border和padding，指的是content+padding+border。 调试方法要学会使用border进行CSS的调试，可以说不会border调试方法就不要写CSS啦~.~ 实现一个宽度自适应的1:1的div123div&#123; padding-top: 100%;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"CSS学习笔记","slug":"CSS学习笔记","date":"2019-05-09T12:21:25.000Z","updated":"2019-05-19T00:53:38.247Z","comments":true,"path":"2019/05/09/CSS学习笔记/","link":"","permalink":"http://yoursite.com/2019/05/09/CSS学习笔记/","excerpt":"","text":"CSS学习笔记导航栏的CSS简单实现利用css可以将垂直展示的ul,ol列表转变为水平展示的导航栏html代码： 123456789&lt;ul class=&quot;clearfix&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;关于&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;技能&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;作品&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;博客&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;日历&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;联系方式&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;其他&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; css代码1234567891011clearfix::after&#123; content:&quot;&quot;; display:block; clear:both;&#125;li &#123;float: left;margin-left: 17px;margin-right: 17px;&#125; 可以记住口诀：子元素加float属性，父元素使用clearfix 高度是由什么决定的块级元素块级元素相对简单，高度是由其内部文档流高度总和决定的。那么什么是文档流呢？文档流即是文档内的元素流动方向。内联元素是从左往右流动的，当宽度不足时，自动换行。块级元素是从上往下流动的。 内联元素内联元素相对复杂，其中font-size的问题最为经典，font-size的值指字体最低的部分到字体最高部分的距离，而为了展示效果，默认行高根据不同字体有所差异。我们也可以通过line-height属性来设置建议行高，然后只有在字体大小较小时，line-height才生效。 css画一个三角形html代码：1&lt;div class=&quot;triangle&quot;&gt;&lt;/div&gt; css代码：123456.triangle&#123; width:0; border:20px solid transparent; border-top-width:0; border-left-color:blue;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"HTTP常用标签","slug":"HTTP常用标签","date":"2019-05-08T15:03:57.000Z","updated":"2019-05-19T00:53:44.332Z","comments":true,"path":"2019/05/08/HTTP常用标签/","link":"","permalink":"http://yoursite.com/2019/05/08/HTTP常用标签/","excerpt":"","text":"HTML常用标签HTML 常用标签iframe标签HTML内联框架元素 iframe表示嵌套的浏览上下文，有效地将另一个HTML页面嵌入到当前页面中。 属性 frameborder 取值为1时（默认值），告诉浏览器在当前iframe与其他iframe之间绘制边框，取0时则无需绘制此边框。默认的比较丑，一般取0。 height 以CSS像素格式指定frame的高度。 width 以CSS像素格式或以百分比格式指定frame的宽度。 name 嵌入的浏览上下文（框架）的名称。该名称可以用作标签a，form的target属性值，或者标签input，button的formtaget属性值。 src 嵌套页面的URL地址。使用遵守同源策略的 ‘about:blank’ 来嵌套空白页。 a标签HTML 元素 (或锚元素) 可以创建一个到其他网页、文件、同一页面内的位置、电子邮件地址或任何其他URL的超链接。 属性 download 此属性指示浏览器下载URL或者文件而不是导航到它，因此将提示用户将其保存为本地文件。此属性仅使用于**同源URL**, 如果不是同源(同域), 将会导航到该URL, 例如: &lt;a href=&quot;http://127.0.0.1:8080/index.html&quot; download=&quot;index&quot;&gt;下载&lt;/a&gt; 会下载同源的一个index.html &lt;a href=&quot;http://qq.com&quot; download=&quot;qq&quot;&gt;下载&lt;/a&gt;, download无效, 将导航到qq.com target: 该属性指定在何处显示链接的资源。 取值为标签（tab），窗口（window），或框架（iframe）等浏览上下文的名称或其他关键词。 target=&quot;_self&quot;: 当前页面加载, 如果没有指定此属性的话, 该值是默认值. target=&quot;_blank&quot;: 新窗口打开 target=&quot;_parent&quot;: 会加载到当前页面的父页面, 如果没有父页面,则等同于_self targe=&quot;_top&quot;: 会加载到最顶层页面, 祖先级页面, 当index1.html包含index2.html, index2.html包含index3.html, 则index3.html中的跳转则会加载到index1.html上 href 包含超链接指向的URL或URL片段。 &lt;a href=&quot;qq.com&quot;&gt;QQ&lt;/a&gt;:,点击QQ不会跳转到qq.com 会把qq.com当成文件, 不是以.com为后缀就是网址,也可以是文件 &lt;a href=&quot;//qq.com&quot;&gt;QQ&lt;/a&gt;, 不写协议的时候, 无协议绝对地址, 默认是当前页面协议, 是file协议, 就跳转file://qq.com, 是HTTP协议, 就跳转到http://qq.com &lt;a href=&quot;xxx.html&quot;&gt;xxx&lt;/a&gt;, 相对路径, 路径只会以目录为参考, 如果在index.html中跳转, 并不会以index.html为前缀index.html/xxx.html, 会显示xxx.html &lt;a href=&quot;#1&quot;&gt;1ink&lt;/a&gt;, 写锚点, 会自动加到后面, 不会发起请求, index.html#1, 虽然不会发起请求,但是页面会有变化. &lt;a href=&quot;?name=xxx&quot;&gt;query&lt;/a&gt;, 写参数, 会自动加到后面, 并发起GET请求, index.html?name=xxx &lt;a href=&quot;javascript: alert(1)&quot;&gt;js&lt;/a&gt;, 伪协议, 会执行js代码. &lt;a href=&quot;javascript:;&quot;&gt;js&lt;/a&gt;, 伪协议, 使其标签点击而不做任何动作，可以实现某些奇葩需求 &lt;a href=&quot;&quot;&gt;blank&lt;/a&gt;, 什么也不写, 页面会刷新, 跳转到了自己. name 和iframe配合使用 form标签HTML元素 表示了文档中的一个区域，这个区域包含有交互控制元件，用来向web服务器提交信息。 a标签和form标签都是跳转, 区别就是a标签发起的是GET请求, form标签发起的是POST请求. 属性 action提交(POST)数据所到的地方.action=&quot;users&quot;, 就是提交到users, 一个处理这个form信息的程序所在的URL.method浏览器使用这种指定方式来提交 form, GET一般不用写, 如果是GET, 提交的数据会被作为查询参数, 并不会放到第四部分作为formdata, POST会把提交的数据放到formdata里, 如果要给POST加查询参数, 可以通过给URL加查询参数?query=xxx target和a标签相同nameHTML5中，一个文档中的多个form当中，name必须唯一而不仅仅是一个空字符串. 也可以与iframe标签配合使用. 如果form标签没有提交按钮, 则无法提交, html里只有form标签能提交数据，提交按钮可以是有一个 input type=submit 的元素或者有一个 button 元素，button 的 type 属性为空 input标签HTML input 元素用于为基于Web的表单创建交互式控件，以便接受来自用户的数据。使用input标签提交数据, 必须有name属性. 属性 type 要呈现的控件类型 type=&quot;button&quot;: 普通按钮 type=&quot;checkbox&quot;: 复选框。必须使用 value 属性定义此控件被提交时的值 color： 用于指定颜色的控件。 date：用于输入日期的控件（年，月，日，不包括时间）。 datetime：基于 UTC 时区的日期时间输入控件（时，分，秒及几分之一秒）。 datetime-local：用于输入日期时间控件，不包含时区。 email：用于编辑 e-mail 的字段。 合适的时候可以使用 file：此控件可以让用户选择文件。使用 accept 属性可以定义控件可以选择的文件类型。 hidden：不显示在页面上的控件，但它的值会被提交到服务器。 image：图片提交按钮。必须使用 src 属性定义图片的来源及使用 alt 定义替代文本。还可以使用 height 和 width 属性以像素为单位定义图片的大小。 month：用于输入年月的控件，不带时区。 number:用于输入浮点数的控件。 password：一个值被遮盖的单行文本字段。使用 maxlength 指定可以输入的值的最大长度 。 radio：单选按钮。必须使用 value 属性定义此控件被提交时的值。使用checked 必须指示控件是否缺省被选择。在同一个”单选按钮组“中，所有单选按钮的 name 属性使用同一个值； 一个单选按钮组中是，同一时间只有一个单选按钮可以被选择。 reset：用于将表单所内容设置为缺省值的按钮。 search：用于输入搜索字符串的单行文本字段。换行会被从输入的值中自动移除。 submit：用于提交表单的按钮。 tel： 用于输入电话号码的控件；换行会被自动从输入的值中移除A，但不会执行其他语法。可以使用属性，比如 pattern 和 maxlength 来约束控件输入的值。恰当的时候，可以应用 text：单行字段；换行会将自动从输入的值中移除。 time：用于输入不含时区的时间控件。 url：用于编辑URL的字段。 The user may enter a blank or invalid address. 换行会被自动从输入值中移队。可以使用如：pattern 和 maxlength 样的属性来约束输入的值。 恰当的时候使可以应用 week：用于输入一个由星期-年组成的日期，日期不包括时区。 autocomplete这个属性表示这个控件的值是否可被浏览器自动填充。如果type属性的值是hidden、checkbox、radio、file，或为按钮类型（button、submit、reset、image），则本属性被忽略。 autofocus这个布尔属性允许您指定的表单控件在页面加载时具有焦点（自动获得焦点），除非用户将其覆盖，例如通过键入不同的控件。文档中只有一个表单元素可以具有autofocus属性，它是一个布尔值。 如果type属性设置为隐藏则不能应用（即您不能自动获得焦点的属性设置为隐藏的控件）。 disabled这个布尔属性表示此表单控件不可用。 特别是在禁用的控件中， click 事件 [将不会被分发]。 并且，禁用的控件的值在提交表单时也不会被提交。如果 type 属性为 hidden，此属性将被忽略。 小Tips:可以使用将input元素嵌入到label元素中达到点击文本时自动将焦点移动到input上元素上 button标签HTML button 元素表示一个可点击的按钮，可以用在表单或文档其它需要使用简单标准按钮的地方 input和button区别: 是否是空元素, button有子元素, input没有 属性 typebutton的类型 submit: 此按钮将表单数据提交给服务器。如果未指定属性，或者属性动态更改为空值或无效值，则此值为默认值。 reset: 此按钮重置所有组件为初始值。 button: 此按钮没有默认行为。它可以有与元素事件相关的客户端脚本，当事件出现时可触发。 menu: 此按钮打开一个由指定元素进行定义的弹出菜单。 namebutton的名称，与表单数据一起提交。 valuebutton的初始值。它定义的值与表单数据的提交按钮相关联。当表单中的数据被提交时，这个值便以参数的形式被递送至服务器。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"HTTP请求和响应初探","slug":"HTTP请求和响应初探","date":"2019-05-04T13:23:27.000Z","updated":"2019-05-19T00:53:49.797Z","comments":true,"path":"2019/05/04/HTTP请求和响应初探/","link":"","permalink":"http://yoursite.com/2019/05/04/HTTP请求和响应初探/","excerpt":"","text":"HTTP请求和响应初探HTTP协议作为前端开发者必须掌握的知识点，它的作用就是知道浏览器和服务器如何进行沟通。下面我们就分别用命令行和Chrome开发者工具来初步探索HTTP请求和响应的内容。 HTTP请求使用命令行curl命令请求示例在命令行中输入如下命令： 1curl -s -v -H \"User: xxx\" -- \"https://www.baidu.com\" 简单分析一下我们创造的命令，curl用来创造一个请求，-s是-silent的缩写，表示不显示进度条和错误信息，-v是-verbose的缩写，常用于debug时候查找详细信息，-H “User: xxx”表示自定义一个header。接下来我们关注一下命令行显示的请求内容为： 12345GET / HTTP/1.1Host: www.baidu.comUser-Agent: curl/7.63.0Accept: */*User: xxx 然后我们把请求的方式变成POST，在命令行中输入如下命令： 1curl -X POST -s -v -H \"User: xxx\" -- \"https://www.baidu.com\" 得到的请求内容为： 12345POST / HTTP/1.1Host: www.baidu.comUser-Agent: curl/7.63.0Accept: */*User: xxx ​ 我们继续在POST请求的基础上加入-d data内容： 1curl -X POST -d \"1234567890\" -s -v -H \"User: xxx\" -- \"https://www.baidu.com\" 得到的请求内容为： 123456789POST / HTTP/1.1Host: www.baidu.comUser-Agent: curl/7.63.0Accept: */*User: xxxContent-Length: 10Content-Type: application/x-www-form-urlencoded1234567890 ​ ` 使用Chrome开发者工具查看请求内容 打开chrome,按F12，点击Network 输入网址https://www.baidu.com/ 选中第一个响应 查看 Request Headers，点击「view source」，会看到如下图所示的请求内容 请求的格式我们已经通过curl命令和Chorme开发者工具两种方式看到了HTTP的请求内容，下面我们总结一下HTTP请求的格式 1234567891 动词 路径 协议/版本2 Key1: value12 Key2: value22 Key3: value32 Content-Type: application/x-www-form-urlencoded2 Host: www.baidu.com2 User-Agent: curl/7.54.03 4 要上传的数据 请求最多包含四部分，最少包含三部分。（也就是说第四部分可以为空） 第三部分永远都是一个回车（\\n） 动词有 GET POST PUT PATCH DELETE HEAD OPTIONS 等 这里的路径包括「查询参数」，但不包括「锚点」 如果你没有写路径，那么路径默认为 / 第 2 部分中的 Content-Type 标注了第 4 部分的格式 第3部分只是一个空行，目的是为了区分第2部分和第4部分要上传的数据 HTTP响应请求了之后，应该都能得到一个响应，除非断网了，或者服务器宕机了。 响应示例上面三个请求示例，前两个请求对应的响应分别为 1234567891011121314151617181920212223242526HTTP/1.1 200 OKAccept-Ranges: bytesCache-Control: private, no-cache, no-store, proxy-revalidate, no-transformConnection: Keep-AliveContent-Length: 2443Content-Type: text/htmlDate: Tue, 10 Oct 2017 09:14:05 GMTEtag: &quot;5886041d-98b&quot;Last-Modified: Mon, 23 Jan 2017 13:24:45 GMTPragma: no-cacheServer: bfe/1.0.8.18Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt; 后面太长，省略了……HTTP/1.1 302 FoundConnection: Keep-AliveContent-Length: 17931Content-Type: text/htmlDate: Tue, 10 Oct 2017 09:19:47 GMTEtag: &quot;54d9749e-460b&quot;Server: bfe/1.0.8.18&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt; 后面太长，省略了…… GET 请求和 POST 请求对应的响应可以一样，也可以不一样 响应的第四部分可以很长很长很长 响应的格式12345671 协议/版本号 状态码 状态解释2 Key1: value12 Key2: value22 Content-Length: 179312 Content-Type: text/html34 要下载的内容 状态码要背，是服务器对浏览器说的话 1xx 不常用 2xx 表示成功 3xx 表示滚吧 4xx 表示你丫错了 5xx 表示好吧，我错了 状态解释没什么用 第 2 部分中的 Content-Type 标注了第 4 部分的格式 第 2 部分中的 Content-Type 遵循 MIME 规范 用 Chrome 查看响应 打开 Network 输入网址 选中第一个响应 查看 Response Headers，点击「view source」 你会看到响应的前两部分 查看 Response 或者 Preview，你会看到响应的第 4 部分","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]}]}