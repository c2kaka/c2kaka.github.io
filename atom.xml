<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>欧阳帆</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-22T08:44:18.593Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>kaka</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用公式理解JS原型链</title>
    <link href="http://yoursite.com/2019/05/22/%E7%94%A8%E5%85%AC%E5%BC%8F%E7%90%86%E8%A7%A3JS%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://yoursite.com/2019/05/22/用公式理解JS原型链/</id>
    <published>2019-05-22T08:31:27.000Z</published>
    <updated>2019-05-22T08:44:18.593Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用公式理解JS原型链"><a href="#用公式理解JS原型链" class="headerlink" title="用公式理解JS原型链"></a>用公式理解JS原型链</h1><p>重要公式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 对象 = <span class="keyword">new</span> 构造函数();</span><br><span class="line">对象.__proto__ === 构造函数.protoType <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//推论</span></span><br><span class="line"><span class="keyword">var</span> number = <span class="keyword">new</span> <span class="built_in">Number</span>();</span><br><span class="line">number.__proto__ === <span class="built_in">Number</span>.protoType <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">object.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="function"><span class="keyword">function</span> = <span class="title">new</span> <span class="title">Function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"><span class="title">function</span>.<span class="title">__proto__</span> === <span class="title">Function</span>.<span class="title">prototype</span> //<span class="title">true</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 另外，所有函数都是由 <span class="title">Function</span> 构造出来的，所以</span></span><br><span class="line"><span class="function"><span class="title">Number</span>.<span class="title">__proto__</span> === <span class="title">Function</span>.<span class="title">prototype</span> // 因为 <span class="title">Number</span> 是函数，是 <span class="title">Function</span> 的实例</span></span><br><span class="line"><span class="function"><span class="title">Object</span>.<span class="title">__proto__</span> === <span class="title">Function</span>.<span class="title">prototype</span> // 因为 <span class="title">Object</span> 是函数，是 <span class="title">Function</span> 的实例</span></span><br><span class="line"><span class="function"><span class="title">Function</span>.<span class="title">__proto__</span> === <span class="title">Function</span>.<span class="title">prototye</span> // 因为 <span class="title">Function</span> 是函数，是 <span class="title">Function</span> 的实例！</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/05/22/5ce509ea57fc457733.png" alt="原型链2.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;用公式理解JS原型链&quot;&gt;&lt;a href=&quot;#用公式理解JS原型链&quot; class=&quot;headerlink&quot; title=&quot;用公式理解JS原型链&quot;&gt;&lt;/a&gt;用公式理解JS原型链&lt;/h1&gt;&lt;p&gt;重要公式&lt;/p&gt;
&lt;figure class=&quot;highlight java
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS数据类型转换</title>
    <link href="http://yoursite.com/2019/05/22/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2019/05/22/JS数据类型转换/</id>
    <published>2019-05-22T02:12:52.000Z</published>
    <updated>2019-05-22T02:40:51.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS数据类型转换"><a href="#JS数据类型转换" class="headerlink" title="JS数据类型转换"></a>JS数据类型转换</h1><h2 id="1-any-to-string"><a href="#1-any-to-string" class="headerlink" title="1.any to string"></a>1.any to string</h2><ul><li>使用<code>toString()</code></li><li>使用<code>String()</code>转换</li><li>和空字符串相加<code>+&#39;&#39;</code></li></ul><h2 id="2-any-to-boolean"><a href="#2-any-to-boolean" class="headerlink" title="2.any to boolean"></a>2.any to boolean</h2><ul><li><p>使用<code>Boolean()</code>转换</p></li><li><p><code>!!a</code></p></li></ul><p>六个falsy值</p><ol><li><code>false</code></li><li><code>null</code></li><li><code>0</code></li><li><code>NaN</code></li><li><code>undefined</code></li><li><code>&#39;&#39;</code></li></ol><p>对象<code>object</code>转换为<code>boolean</code>都为<code>true</code></p><h2 id="3-string-to-number"><a href="#3-string-to-number" class="headerlink" title="3.string to number"></a>3.string to number</h2><ul><li>使用<code>Number()</code>转换</li><li><code>parseInt()</code> 和 <code>parseFloat()</code></li><li><code>&#39;1&#39;-0</code></li><li><code>+&#39;1&#39;</code></li></ul><h2 id="4-JS内存图解"><a href="#4-JS内存图解" class="headerlink" title="4.JS内存图解"></a>4.JS内存图解</h2><h3 id="4-1概述"><a href="#4-1概述" class="headerlink" title="4.1概述"></a>4.1概述</h3><p><img src="https://i.loli.net/2019/05/22/5ce4b47155b9081701.png" alt="内存图解.png"></p><p>初始类型的值如string、boolean、number存在Stack栈内存中，而object将Heap堆内存的地址存在Stack栈内存中。</p><h3 id="4-2常见考题"><a href="#4-2常见考题" class="headerlink" title="4.2常见考题"></a>4.2常见考题</h3><p><img src="https://i.loli.net/2019/05/22/5ce4b5a08229f10745.png" alt="QQ截图20190522093646.png"></p><p>遇到上述题目，可以先画内存图解，但是要注意 <code>a.x = a = {n:2};</code>是先确定a的内存地址再进行赋值的</p><h3 id="4-3GC垃圾回收的简单理解"><a href="#4-3GC垃圾回收的简单理解" class="headerlink" title="4.3GC垃圾回收的简单理解"></a>4.3GC垃圾回收的简单理解</h3><p>如果一个对象没有被引用，它就是垃圾，可以被回收，可以画出内存图解方便理解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JS数据类型转换&quot;&gt;&lt;a href=&quot;#JS数据类型转换&quot; class=&quot;headerlink&quot; title=&quot;JS数据类型转换&quot;&gt;&lt;/a&gt;JS数据类型转换&lt;/h1&gt;&lt;h2 id=&quot;1-any-to-string&quot;&gt;&lt;a href=&quot;#1-any-to-strin
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>JS数据类型</title>
    <link href="http://yoursite.com/2019/05/21/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/05/21/JS数据类型/</id>
    <published>2019-05-21T10:28:00.000Z</published>
    <updated>2019-05-21T13:30:15.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS数据类型"><a href="#JS数据类型" class="headerlink" title="JS数据类型"></a>JS数据类型</h1><h2 id="1-数据类型概述"><a href="#1-数据类型概述" class="headerlink" title="1.数据类型概述"></a>1.数据类型概述</h2><p>JS的数据类型共有七种：</p><ul><li><p><code>number</code>(数值)：整数和小数（比如1和3.14）</p></li><li><p><code>string</code>(字符串)：文本（比如 hello world）</p></li><li><p><code>boolean</code>(布尔值)：true和false</p></li><li><p><code>object</code>(对象)：各种值的集合</p></li><li><p><code>undefined</code>：表示“未定义”或者不存在</p></li><li><p><code>null</code>：表示空值</p></li><li><p><code>symbol</code>：es6新增</p></li></ul><p><code>number</code>、<code>string</code>、<code>boolean</code>这三种类型合称为原始类型的值，即是最基本的数据类型，不能再细分了。而object被称为合成类型的值，即是各种值的集合。至于<code>undefined</code>和<code>null</code>可以看成两个特殊的值。</p><h2 id="2-null-和-undefined"><a href="#2-null-和-undefined" class="headerlink" title="2.null 和 undefined"></a>2.null 和 undefined</h2><h3 id="2-1概述"><a href="#2-1概述" class="headerlink" title="2.1概述"></a>2.1概述</h3><p><code>null</code>与<code>undefined</code>都可以表示“没有”，含义非常相似。将一个变量赋值为<code>undefined</code>或<code>null</code>，老实说，语法效果几乎没区别。在<code>if</code>语句中，它们都会被自动转为<code>false</code>，相等运算符（<code>==</code>）甚至直接报告两者相等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="literal">undefined</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'undefined is false'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// undefined is false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'null is false'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// null is false</span></span><br><span class="line"></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">null</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="2-2用法和含义"><a href="#2-2用法和含义" class="headerlink" title="2.2用法和含义"></a>2.2用法和含义</h3><p>当你声明一个对象而又不想立即赋值时，可以将对象设为<code>null</code>，表示空值；而当你声明一个原始类型的值而又不想立即赋值时，可以用<code>undefined</code>。</p><h2 id="3-boolean"><a href="#3-boolean" class="headerlink" title="3.boolean"></a>3.boolean</h2><p>如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为<code>false</code>，其他值都视为<code>true</code>。</p><ul><li><p><code>undefined</code></p></li><li><p><code>null</code></p></li><li><p><code>false</code></p></li><li><p><code>0</code></p></li><li><p><code>NaN</code></p></li><li><p><code>&quot;&quot;</code>或<code>&#39;&#39;</code>（空字符串）</p></li></ul><h2 id="4-number"><a href="#4-number" class="headerlink" title="4.number"></a>4.number</h2><h3 id="4-1整数和浮点数"><a href="#4-1整数和浮点数" class="headerlink" title="4.1整数和浮点数"></a>4.1整数和浮点数</h3><p>JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，<code>1</code>与<code>1.0</code>是相同的，是同一个数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> === <span class="number">1.0</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数，然后再进行运算。</p><p>由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.3</span> / <span class="number">0.1</span></span><br><span class="line"><span class="comment">// 2.9999999999999996</span></span><br><span class="line"></span><br><span class="line">(<span class="number">0.3</span> - <span class="number">0.2</span>) === (<span class="number">0.2</span> - <span class="number">0.1</span>)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="4-2数值范围"><a href="#4-2数值范围" class="headerlink" title="4.2数值范围"></a>4.2数值范围</h3><p>根据标准，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则 JavaScript 能够表示的数值范围为21024到2-1023（开区间），超出这个范围的数无法表示。</p><p>如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回<code>Infinity</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">1024</span>) <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure><p>如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回0。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">-1075</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h3 id="4-3进制"><a href="#4-3进制" class="headerlink" title="4.3进制"></a>4.3进制</h3><p>JavaScript 对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。</p><ul><li>十进制：没有前导0的数值。</li><li>八进制：有前缀<code>0o</code>或<code>0O</code>的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。</li><li>十六进制：有前缀<code>0x</code>或<code>0X</code>的数值。</li><li>二进制：有前缀<code>0b</code>或<code>0B</code>的数值。</li></ul><h3 id="4-4NaN"><a href="#4-4NaN" class="headerlink" title="4.4NaN"></a>4.4NaN</h3><h4 id="4-4-1含义"><a href="#4-4-1含义" class="headerlink" title="4.4.1含义"></a>4.4.1含义</h4><p><code>NaN</code>是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> - <span class="string">'x'</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p>上面代码运行时，会自动将字符串<code>x</code>转为数值，但是由于<code>x</code>不是数值，所以最后得到结果为<code>NaN</code>，表示它是“非数字”（<code>NaN</code>）。</p><p>另外，一些数学函数的运算结果会出现<code>NaN</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.acos(<span class="number">2</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.log(<span class="number">-1</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.sqrt(<span class="number">-1</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p><code>0</code>除以<code>0</code>也会得到<code>NaN</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> / <span class="number">0</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p>需要注意的是，<code>NaN</code>不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于<code>Number</code>，使用<code>typeof</code>运算符可以看得很清楚。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span> <span class="comment">// 'number'</span></span><br></pre></td></tr></table></figure><h4 id="4-4-2运算规则"><a href="#4-4-2运算规则" class="headerlink" title="4.4.2运算规则"></a>4.4.2运算规则</h4><p><code>NaN</code>不等于任何值，包括它本身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>数组的<code>indexOf</code>方法内部使用的是严格相等运算符，所以该方法对<code>NaN</code>不成立。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure><p><code>NaN</code>在布尔运算时被当作<code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="literal">NaN</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><code>NaN</code>与任何数（包括它自己）的运算，得到的都是<code>NaN</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span> + <span class="number">32</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">NaN</span> - <span class="number">32</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">NaN</span> * <span class="number">32</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">NaN</span> / <span class="number">32</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><h3 id="4-5parseInt"><a href="#4-5parseInt" class="headerlink" title="4.5parseInt()"></a>4.5parseInt()</h3><h4 id="4-5-1基本用法"><a href="#4-5-1基本用法" class="headerlink" title="4.5.1基本用法"></a>4.5.1基本用法</h4><p><code>parseInt</code>方法用于将字符串转为整数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'123'</span>) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>如果字符串头部有空格，空格会被自动去除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'   81'</span>) <span class="comment">// 81</span></span><br></pre></td></tr></table></figure><p>如果<code>parseInt</code>的参数不是字符串，则会先转为字符串再转换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">1.23</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1.23'</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'8a'</span>) <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'12**'</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'12.34'</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'15e2'</span>) <span class="comment">// 15</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'15px'</span>) <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>parseInt</code>的参数都是字符串，结果只返回字符串头部可以转为数字的部分。</p><p>如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回<code>NaN</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'abc'</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'.3'</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">''</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'+'</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'+1'</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>所以，<code>parseInt</code>的返回值只有两种可能，要么是一个十进制整数，要么是<code>NaN</code>。</p><p>如果字符串以<code>0x</code>或<code>0X</code>开头，<code>parseInt</code>会将其按照十六进制数解析。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'0x10'</span>) <span class="comment">// 16</span></span><br></pre></td></tr></table></figure><p>如果字符串以<code>0</code>开头，将其按照10进制解析。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'011'</span>) <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><p>对于那些会自动转为科学计数法的数字，<code>parseInt</code>会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">1000000000000000000000.5</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1e+21'</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">0.0000008</span>) <span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'8e-7'</span>) <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><h4 id="4-5-2进制转换"><a href="#4-5-2进制转换" class="headerlink" title="4.5.2进制转换"></a>4.5.2进制转换</h4><p><code>parseInt</code>方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。默认情况下，<code>parseInt</code>的第二个参数为10，即默认是十进制转十进制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1000'</span>) <span class="comment">// 1000</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1000'</span>, <span class="number">10</span>) <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure><p>下面是转换指定进制的数的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1000'</span>, <span class="number">2</span>) <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1000'</span>, <span class="number">6</span>) <span class="comment">// 216</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1000'</span>, <span class="number">8</span>) <span class="comment">// 512</span></span><br></pre></td></tr></table></figure><p>上面代码中，二进制、六进制、八进制的<code>1000</code>，分别等于十进制的8、216和512。这意味着，可以用<code>parseInt</code>方法进行进制的转换。</p><p>如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回<code>NaN</code>。如果第二个参数是<code>0</code>、<code>undefined</code>和<code>null</code>，则直接忽略。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>, <span class="number">37</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>, <span class="number">1</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>, <span class="number">0</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>, <span class="literal">null</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>, <span class="literal">undefined</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。如果最高位无法转换，则直接返回<code>NaN</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1546'</span>, <span class="number">2</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'546'</span>, <span class="number">2</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p>上面代码中，对于二进制来说，<code>1</code>是有意义的字符，<code>5</code>、<code>4</code>、<code>6</code>都是无意义的字符，所以第一行返回1，第二行返回<code>NaN</code>。</p><p>前面说过，如果<code>parseInt</code>的第一个参数不是字符串，会被先转为字符串。这会导致一些令人意外的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">0x11</span>, <span class="number">36</span>) <span class="comment">// 43</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">0x11</span>, <span class="number">2</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="built_in">String</span>(<span class="number">0x11</span>), <span class="number">36</span>)</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="built_in">String</span>(<span class="number">0x11</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'17'</span>, <span class="number">36</span>)</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'17'</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>上面代码中，十六进制的<code>0x11</code>会被先转为十进制的17，再转为字符串。然后，再用36进制或二进制解读字符串<code>17</code>，最后返回结果<code>43</code>和<code>1</code>。</p><p>这种处理方式，对于八进制的前缀0，尤其需要注意。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">011</span>, <span class="number">2</span>) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="built_in">String</span>(<span class="number">011</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="built_in">String</span>(<span class="number">9</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>上面代码中，第一行的<code>011</code>会被先转为字符串<code>9</code>，因为<code>9</code>不是二进制的有效字符，所以返回<code>NaN</code>。如果直接计算<code>parseInt(&#39;011&#39;, 2)</code>，<code>011</code>则是会被当作二进制处理，返回3。</p><p>JavaScript 不再允许将带有前缀0的数字视为八进制数，而是要求忽略这个<code>0</code>。但是，为了保证兼容性，大部分浏览器并没有部署这一条规定。</p><h3 id="4-6-parseFloat"><a href="#4-6-parseFloat" class="headerlink" title="4.6 parseFloat()"></a>4.6 parseFloat()</h3><p><code>parseFloat</code>方法用于将一个字符串转为浮点数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'3.14'</span>) <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure><p>如果字符串符合科学计数法，则会进行相应的转换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'314e-2'</span>) <span class="comment">// 3.14</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'0.0314E+2'</span>) <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure><p>如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'3.14more non-digit characters'</span>) <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure><p><code>parseFloat</code>方法会自动过滤字符串前导的空格。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'\t\v\r12.34\n '</span>) <span class="comment">// 12.34</span></span><br></pre></td></tr></table></figure><p>如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回<code>NaN</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>([]) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'FF2'</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">''</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p>上面代码中，尤其值得注意，<code>parseFloat</code>会将空字符串转为<code>NaN</code>。</p><p>这些特点使得<code>parseFloat</code>的转换结果不同于<code>Number</code>函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="literal">true</span>)  <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="literal">null</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">''</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">''</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'123.45#'</span>) <span class="comment">// 123.45</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'123.45#'</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><h3 id="4-6-isNaN"><a href="#4-6-isNaN" class="headerlink" title="4.6 isNaN()"></a>4.6 isNaN()</h3><p><code>isNaN</code>方法可以用来判断一个值是否为<code>NaN</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">123</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>但是，<code>isNaN</code>只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成<code>NaN</code>，所以最后返回<code>true</code>，这一点要特别引起注意。也就是说，<code>isNaN</code>为<code>true</code>的值，有可能不是<code>NaN</code>，而是一个字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="string">'Hello'</span>) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="built_in">Number</span>(<span class="string">'Hello'</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>出于同样的原因，对于对象和数组，<code>isNaN</code>也返回<code>true</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(&#123;&#125;) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="built_in">Number</span>(&#123;&#125;)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isNaN</span>([<span class="string">'xzy'</span>]) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="built_in">Number</span>([<span class="string">'xzy'</span>])) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>但是，对于空数组和只有一个数值成员的数组，<code>isNaN</code>返回<code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>([]) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>([<span class="number">123</span>]) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>([<span class="string">'123'</span>]) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码之所以返回<code>false</code>，原因是这些数组能被<code>Number</code>函数转成数值，请参见《数据类型转换》一章。</p><p>因此，使用<code>isNaN</code>之前，最好判断一下数据类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myIsNaN</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">'number'</span> &amp;&amp; <span class="built_in">isNaN</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断<code>NaN</code>更可靠的方法是，利用<code>NaN</code>为唯一不等于自身的值的这个特点，进行判断。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myIsNaN</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value !== value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-string"><a href="#5-string" class="headerlink" title="5.string"></a>5.string</h2><h3 id="5-1概述"><a href="#5-1概述" class="headerlink" title="5.1概述"></a>5.1概述</h3><p>字符串默认只能写在一行内，分成多行将会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&apos;a</span><br><span class="line">b</span><br><span class="line">c&apos;</span><br><span class="line">// SyntaxError: Unexpected token ILLEGAL</span><br></pre></td></tr></table></figure><p>上面代码将一个字符串分成三行，JavaScript 就会报错。</p><p>如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> longString = <span class="string">'Long \</span></span><br><span class="line"><span class="string">long \</span></span><br><span class="line"><span class="string">long \</span></span><br><span class="line"><span class="string">string'</span>;</span><br><span class="line"></span><br><span class="line">longString</span><br><span class="line"><span class="comment">// "Long long long string"</span></span><br></pre></td></tr></table></figure><p>上面代码表示，加了反斜杠以后，原来写在一行的字符串，可以分成多行书写。但是，输出的时候还是单行，效果与写在同一行完全一样。注意，反斜杠的后面必须是换行符，而不能有其他字符（比如空格），否则会报错。</p><p>连接运算符（<code>+</code>）可以连接多个单行字符串，将长字符串拆成多行书写，输出的时候也是单行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> longString = <span class="string">'Long '</span></span><br><span class="line">  + <span class="string">'long '</span></span><br><span class="line">  + <span class="string">'long '</span></span><br><span class="line">  + <span class="string">'string'</span>;</span><br></pre></td></tr></table></figure><p>es6中，可以使用反引号：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> longString = <span class="string">`a</span></span><br><span class="line"><span class="string">  b</span></span><br><span class="line"><span class="string">  c`</span></span><br></pre></td></tr></table></figure><h3 id="5-2字符串与数组"><a href="#5-2字符串与数组" class="headerlink" title="5.2字符串与数组"></a>5.2字符串与数组</h3><p>字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'hello'</span>;</span><br><span class="line">s[<span class="number">0</span>] <span class="comment">// "h"</span></span><br><span class="line">s[<span class="number">1</span>] <span class="comment">// "e"</span></span><br><span class="line">s[<span class="number">4</span>] <span class="comment">// "o"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接对字符串使用方括号运算符</span></span><br><span class="line"><span class="string">'hello'</span>[<span class="number">1</span>] <span class="comment">// "e"</span></span><br></pre></td></tr></table></figure><p>如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回<code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abc'</span>[<span class="number">3</span>] <span class="comment">// undefined</span></span><br><span class="line"><span class="string">'abc'</span>[<span class="number">-1</span>] <span class="comment">// undefined</span></span><br><span class="line"><span class="string">'abc'</span>[<span class="string">'x'</span>] <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> s[<span class="number">0</span>];</span><br><span class="line">s <span class="comment">// "hello"</span></span><br><span class="line"></span><br><span class="line">s[<span class="number">1</span>] = <span class="string">'a'</span>;</span><br><span class="line">s <span class="comment">// "hello"</span></span><br><span class="line"></span><br><span class="line">s[<span class="number">5</span>] = <span class="string">'!'</span>;</span><br><span class="line">s <span class="comment">// "hello"</span></span><br></pre></td></tr></table></figure><p>上面代码表示，字符串内部的单个字符无法改变和增删，这些操作会默默地失败。</p><p><code>length</code>属性返回字符串的长度，该属性也是无法改变的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'hello'</span>;</span><br><span class="line">s.length <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">s.length = <span class="number">3</span>;</span><br><span class="line">s.length <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">s.length = <span class="number">7</span>;</span><br><span class="line">s.length <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>上面代码表示字符串的<code>length</code>属性无法改变，但是不会报错。</p><h3 id="5-3字符集"><a href="#5-3字符集" class="headerlink" title="5.3字符集"></a>5.3字符集</h3><p>JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。</p><p>JavaScript 不仅以 Unicode 储存字符，还允许直接在程序中使用 Unicode 码点表示字符，即将字符写成<code>\uxxxx</code>的形式，其中<code>xxxx</code>代表该字符的 Unicode 码点。比如，<code>\u00A9</code>代表版权符号。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'\u00A9'</span>;</span><br><span class="line">s <span class="comment">// "©"</span></span><br></pre></td></tr></table></figure><p>解析代码的时候，JavaScript 会自动识别一个字符是字面形式表示，还是 Unicode 形式表示。输出给用户的时候，所有字符都会转成字面形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f\u006F\u006F = <span class="string">'abc'</span>;</span><br><span class="line">foo <span class="comment">// "abc"</span></span><br></pre></td></tr></table></figure><p>上面代码中，第一行的变量名<code>foo</code>是 Unicode 形式表示，第二行是字面形式表示。JavaScript 会自动识别。</p><p>我们还需要知道，每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存。也就是说，JavaScript 的单位字符长度固定为16位长度，即2个字节。</p><p>但是，UTF-16 有两种长度：对于码点在<code>U+0000</code>到<code>U+FFFF</code>之间的字符，长度为16位（即2个字节）；对于码点在<code>U+10000</code>到<code>U+10FFFF</code>之间的字符，长度为32位（即4个字节），而且前两个字节在<code>0xD800</code>到<code>0xDBFF</code>之间，后两个字节在<code>0xDC00</code>到<code>0xDFFF</code>之间。举例来说，码点<code>U+1D306</code>对应的字符为<code>𝌆，</code>它写成 UTF-16 就是<code>0xD834 0xDF06</code>。</p><p>JavaScript 对 UTF-16 的支持是不完整的，由于历史原因，只支持两字节的字符，不支持四字节的字符。这是因为 JavaScript 第一版发布的时候，Unicode 的码点只编到<code>U+FFFF</code>，因此两字节足够表示了。后来，Unicode 纳入的字符越来越多，出现了四字节的编码。但是，JavaScript 的标准此时已经定型了，统一将字符长度限制在两字节，导致无法识别四字节的字符。上一节的那个四字节字符<code>𝌆</code>，浏览器会正确识别这是一个字符，但是 JavaScript 无法识别，会认为这是两个字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'𝌆'</span>.length <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，JavaScript 认为<code>𝌆</code>的长度为2，而不是1。</p><p>总结一下，对于码点在<code>U+10000</code>到<code>U+10FFFF</code>之间的字符，JavaScript 总是认为它们是两个字符（<code>length</code>属性为2）。所以处理的时候，必须把这一点考虑在内，也就是说，JavaScript 返回的字符串长度可能是不正确的。</p><h3 id="5-4Base64转码"><a href="#5-4Base64转码" class="headerlink" title="5.4Base64转码"></a>5.4Base64转码</h3><p>有时，文本里面包含一些不可打印的符号，比如 ASCII 码0到31的符号都无法打印出来，这时可以使用 Base64 编码，将它们转成可以打印的字符。另一个场景是，有时需要以文本格式传递二进制数据，那么也可以使用 Base64 编码。</p><p>所谓 Base64 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、<code>+</code>和<code>/</code>这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。</p><p>JavaScript 原生提供两个 Base64 相关的方法。</p><ul><li><code>btoa()</code>：任意值转为 Base64 编码</li><li><code>atob()</code>：Base64 编码转为原来的值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">'Hello World!'</span>;</span><br><span class="line">btoa(string) <span class="comment">// "SGVsbG8gV29ybGQh"</span></span><br><span class="line">atob(<span class="string">'SGVsbG8gV29ybGQh'</span>) <span class="comment">// "Hello World!"</span></span><br></pre></td></tr></table></figure><p>注意，这两个方法不适合非 ASCII 码的字符，会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btoa(<span class="string">'你好'</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b64Encode</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> btoa(<span class="built_in">encodeURIComponent</span>(str));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b64Decode</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">decodeURIComponent</span>(atob(str));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b64Encode(<span class="string">'你好'</span>) <span class="comment">// "JUU0JUJEJUEwJUU1JUE1JUJE"</span></span><br><span class="line">b64Decode(<span class="string">'JUU0JUJEJUEwJUU1JUE1JUJE'</span>) <span class="comment">// "你好"</span></span><br></pre></td></tr></table></figure><h2 id="6-object"><a href="#6-object" class="headerlink" title="6.object"></a>6.object</h2><h3 id="6-1属性的查看"><a href="#6-1属性的查看" class="headerlink" title="6.1属性的查看"></a>6.1属性的查看</h3><p>查看一个对象本身的所有属性，可以使用<code>Object.keys</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  key1: <span class="number">1</span>,</span><br><span class="line">  key2: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(obj);</span><br><span class="line"><span class="comment">// ['key1', 'key2']</span></span><br></pre></td></tr></table></figure><h3 id="6-2属性的删除：delete-命令"><a href="#6-2属性的删除：delete-命令" class="headerlink" title="6.2属性的删除：delete 命令"></a>6.2属性的删除：delete 命令</h3><p><code>delete</code>命令用于删除对象的属性，删除成功后返回<code>true</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.keys(obj) <span class="comment">// ["p"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.p <span class="comment">// true</span></span><br><span class="line">obj.p <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">Object</span>.keys(obj) <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>delete</code>命令删除对象<code>obj</code>的<code>p</code>属性。删除后，再读取<code>p</code>属性就会返回<code>undefined</code>，而且<code>Object.keys</code>方法的返回值也不再包括该属性。</p><p>注意，删除一个不存在的属性，<code>delete</code>不报错，而且返回<code>true</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">delete</span> obj.p <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，对象<code>obj</code>并没有<code>p</code>属性，但是<code>delete</code>命令照样返回<code>true</code>。因此，不能根据<code>delete</code>命令的结果，认定某个属性是存在的。</p><p>只有一种情况，<code>delete</code>命令会返回<code>false</code>，那就是该属性存在，且不得删除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">'p'</span>, &#123;</span><br><span class="line">  value: <span class="number">123</span>,</span><br><span class="line">  configurable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.p <span class="comment">// 123</span></span><br><span class="line"><span class="keyword">delete</span> obj.p <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码之中，对象<code>obj</code>的<code>p</code>属性是不能删除的，所以<code>delete</code>命令返回<code>false</code>（关于<code>Object.defineProperty</code>方法的介绍，请看《标准库》的 Object 对象一章）。</p><p>另外，需要注意的是，<code>delete</code>命令只能删除对象本身的属性，无法删除继承的属性（关于继承参见《面向对象编程》章节）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">delete</span> obj.toString <span class="comment">// true</span></span><br><span class="line">obj.toString <span class="comment">// function toString() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>toString</code>是对象<code>obj</code>继承的属性，虽然<code>delete</code>命令返回<code>true</code>，但该属性并没有被删除，依然存在。这个例子还说明，即使<code>delete</code>返回<code>true</code>，该属性依然可能读取到值。</p><h3 id="6-3属性是否存在：in-运算符"><a href="#6-3属性是否存在：in-运算符" class="headerlink" title="6.3属性是否存在：in 运算符"></a>6.3属性是否存在：in 运算符</h3><p><code>in</code>运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回<code>true</code>，否则返回<code>false</code>。它的左边是一个字符串，表示属性名，右边是一个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="string">'p'</span> <span class="keyword">in</span> obj <span class="comment">// true</span></span><br><span class="line"><span class="string">'toString'</span> <span class="keyword">in</span> obj <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>in</code>运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。就像上面代码中，对象<code>obj</code>本身并没有<code>toString</code>属性，但是<code>in</code>运算符会返回<code>true</code>，因为这个属性是继承的。</p><p>这时，可以使用对象的<code>hasOwnProperty</code>方法判断一下，是否为对象自身的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">'toString'</span> <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">'toString'</span>)) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-4属性的遍历：for…in-循环"><a href="#6-4属性的遍历：for…in-循环" class="headerlink" title="6.4属性的遍历：for…in 循环"></a>6.4属性的遍历：for…in 循环</h3><p><code>for...in</code>循环用来遍历一个对象的全部属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'键名：'</span>, i);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'键值：'</span>, obj[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 键名： a</span></span><br><span class="line"><span class="comment">// 键值： 1</span></span><br><span class="line"><span class="comment">// 键名： b</span></span><br><span class="line"><span class="comment">// 键值： 2</span></span><br><span class="line"><span class="comment">// 键名： c</span></span><br><span class="line"><span class="comment">// 键值： 3</span></span><br></pre></td></tr></table></figure><p><code>for...in</code>循环有两个使用注意点。</p><ul><li>它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。</li><li>它不仅遍历对象自身的属性，还遍历继承的属性。</li></ul><p>举例来说，对象都继承了<code>toString</code>属性，但是<code>for...in</code>循环不会遍历到这个属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// toString 属性是存在的</span></span><br><span class="line">obj.toString <span class="comment">// toString() &#123; [native code] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p);</span><br><span class="line">&#125; <span class="comment">// 没有任何输出</span></span><br></pre></td></tr></table></figure><p>上面代码中，对象<code>obj</code>继承了<code>toString</code>属性，该属性不会被<code>for...in</code>循环遍历到，因为它默认是“不可遍历”的。关于对象属性的可遍历性，参见《标准库》章节中 Object 一章的介绍。</p><p>如果继承的属性是可遍历的，那么就会被<code>for...in</code>循环遍历到。但是，一般情况下，都是只想遍历对象自身的属性，所以使用<code>for...in</code>的时候，应该结合使用<code>hasOwnProperty</code>方法，在循环内部判断一下，某个属性是否为对象自身的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123; <span class="attr">name</span>: <span class="string">'老张'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="keyword">if</span> (person.hasOwnProperty(key)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// name</span></span><br></pre></td></tr></table></figure><h2 id="6-5with-语句"><a href="#6-5with-语句" class="headerlink" title="6.5with 语句"></a>6.5with 语句</h2><p><code>with</code>语句的格式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> (对象) &#123;</span><br><span class="line">  语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的作用是操作同一个对象的多个属性时，提供一些书写的方便。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  p1: <span class="number">1</span>,</span><br><span class="line">  p2: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">with</span> (obj) &#123;</span><br><span class="line">  p1 = <span class="number">4</span>;</span><br><span class="line">  p2 = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">obj.p1 = <span class="number">4</span>;</span><br><span class="line">obj.p2 = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">with</span> (<span class="built_in">document</span>.links[<span class="number">0</span>])&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(href);</span><br><span class="line">  <span class="built_in">console</span>.log(title);</span><br><span class="line">  <span class="built_in">console</span>.log(style);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.links[<span class="number">0</span>].href);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.links[<span class="number">0</span>].title);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.links[<span class="number">0</span>].style);</span><br></pre></td></tr></table></figure><p>注意，如果<code>with</code>区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">with</span> (obj) &#123;</span><br><span class="line">  p1 = <span class="number">4</span>;</span><br><span class="line">  p2 = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.p1 <span class="comment">// undefined</span></span><br><span class="line">p1 <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>上面代码中，对象<code>obj</code>并没有<code>p1</code>属性，对<code>p1</code>赋值等于创造了一个全局变量<code>p1</code>。正确的写法应该是，先定义对象<code>obj</code>的属性<code>p1</code>，然后在<code>with</code>区块内操作它。</p><p>这是因为<code>with</code>区块没有改变作用域，它的内部依然是当前作用域。这造成了<code>with</code>语句的一个很大的弊病，就是绑定对象不明确。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> (obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单纯从上面的代码块，根本无法判断<code>x</code>到底是全局变量，还是对象<code>obj</code>的一个属性。这非常不利于代码的除错和模块化，编译器也无法对这段代码进行优化，只能留到运行时判断，这就拖慢了运行速度。因此，建议不要使用<code>with</code>语句，可以考虑用一个临时变量代替<code>with</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span>(obj1.obj2.obj3) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p1 + p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以写成</span></span><br><span class="line"><span class="keyword">var</span> temp = obj1.obj2.obj3;</span><br><span class="line"><span class="built_in">console</span>.log(temp.p1 + temp.p2);</span><br></pre></td></tr></table></figure><h2 id="7-参考资料"><a href="#7-参考资料" class="headerlink" title="7.参考资料"></a>7.参考资料</h2><p>阮一峰博客<a href="https://wangdoc.com/javascript/types/" target="_blank" rel="noopener">https://wangdoc.com/javascript/types/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JS数据类型&quot;&gt;&lt;a href=&quot;#JS数据类型&quot; class=&quot;headerlink&quot; title=&quot;JS数据类型&quot;&gt;&lt;/a&gt;JS数据类型&lt;/h1&gt;&lt;h2 id=&quot;1-数据类型概述&quot;&gt;&lt;a href=&quot;#1-数据类型概述&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>BFC</title>
    <link href="http://yoursite.com/2019/05/19/BFC/"/>
    <id>http://yoursite.com/2019/05/19/BFC/</id>
    <published>2019-05-19T07:25:25.000Z</published>
    <updated>2019-05-19T07:43:33.349Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BFC（blocking-formatting-context）"><a href="#BFC（blocking-formatting-context）" class="headerlink" title="BFC（blocking formatting context）"></a>BFC（blocking formatting context）</h1><h2 id="BFC的描述"><a href="#BFC的描述" class="headerlink" title="BFC的描述"></a>BFC的描述</h2><h3 id="CSS规范中对-BFC-的描述"><a href="#CSS规范中对-BFC-的描述" class="headerlink" title="CSS规范中对 BFC 的描述"></a>CSS规范中对 BFC 的描述</h3><blockquote><p>9.4.1 块格式化上下文</p></blockquote><blockquote><p>浮动，绝对定位元素，非块盒的块容器（例如，inline-blocks，table-cells和table-captions）和’overflow’不为’visible’的块盒会为它们的内容建立一个新的块格式化上下文</p></blockquote><blockquote><p>在一个块格式化上下文中，盒在竖直方向一个接一个地放置，从包含块的顶部开始。两个兄弟盒之间的竖直距离由’margin’属性决定。同一个块格式化上下文中的相邻块级盒之间的竖直margin会合并</p></blockquote><blockquote><p>在一个块格式化上下文中，每个盒的left外边（left outer edge）挨着包含块的left边（对于从右向左的格式化，right边挨着）。即使存在浮动（尽管一个盒的行盒可能会因为浮动收缩），这也成立。除非该盒建立了一个新的块格式化上下文（这种情况下，该盒自身可能会因为浮动变窄）</p></blockquote><h3 id="MDN-对-BFC-的描述"><a href="#MDN-对-BFC-的描述" class="headerlink" title="MDN 对 BFC 的描述"></a>MDN 对 BFC 的描述</h3><blockquote><p>一个块格式化上下文（block formatting context） 是Web页面的可视化CSS渲染出的一部分。它是块级盒布局出现的区域，也是浮动层元素进行交互的区域。</p></blockquote><blockquote><p>一个块格式化上下文由以下之一创建：</p></blockquote><blockquote><ul><li>根元素或其它包含它的元素</li><li>浮动元素 (元素的 float 不是 none)</li><li>绝对定位元素 (元素具有 position 为 absolute 或 fixed)</li><li>内联块 (元素具有 display: inline-block)</li><li>表格单元格 (元素具有 display: table-cell，HTML表格单元格默认属性)</li><li>表格标题 (元素具有 display: table-caption, HTML表格标题默认属性)</li><li>具有overflow 且值不是 visible 的块元素，</li><li>display: flow-root</li><li>column-span: all 应当总是会创建一个新的格式化上下文，即便具有 column-span: all 的元素并不被包裹在一个多列容器中。</li></ul></blockquote><blockquote><p>一个块格式化上下文包括创建它的元素内部所有内容，除了被包含于创建新的块级格式化上下文的后代元素内的元素。</p></blockquote><blockquote><p>块格式化上下文对于定位 (参见 float) 与清除浮动 (参见 clear) 很重要。定位和清除浮动的样式规则只适用于处于同一块格式化上下文内的元素。浮动不会影响其它块格式化上下文中元素的布局，并且清除浮动只能清除同一块格式化上下文中在它前面的元素的浮动。</p></blockquote><h3 id="张鑫旭对-BFC-的描述"><a href="#张鑫旭对-BFC-的描述" class="headerlink" title="张鑫旭对 BFC 的描述"></a>张鑫旭对 BFC 的描述</h3><p><a href="http://www.zhangxinxu.com/wordpress/2015/02/css-deep-understand-flow-bfc-column-two-auto-layout/" target="_blank" rel="noopener">http://www.zhangxinxu.com/wordpress/2015/02/css-deep-understand-flow-bfc-column-two-auto-layout/</a></p><blockquote><p>BFC全称”Block Formatting Context”, 中文为“块级格式化上下文”。啪啦啪啦特性什么的，一言难尽，大家可以自行去查找，我这里不详述，免得乱了主次，总之，记住这么一句话：BFC元素特性表现原则就是，内部子元素再怎么翻江倒海，翻云覆雨都不会影响外部的元素。所以，避免margin穿透啊，清除浮动什么的也好理解了。</p></blockquote><p>看完这些你是不是已经迷糊了，想知道BFC到底是什么</p><p>先思考一个问题：</p><p>请问：什么是色情？</p><p>联邦最高法院大法官斯图尔特更有一句名言</p><blockquote><p>我不知道什么是色情，不过，我看了之后，就能知道</p></blockquote><p><a href="https://en.wikipedia.org/wiki/I_know_it_when_I_see_it" target="_blank" rel="noopener">I know it when I see it</a></p><p>类似地：</p><ol><li>我不知道什么是 BFC</li><li>但是你写出样式，我就知道这是不是 BFC</li></ol><p>BFC 就是这样的东西（堆叠上下文也是）</p><ol><li>它没有定义</li><li>它只有特性/功能</li></ol><h2 id="BFC的功能"><a href="#BFC的功能" class="headerlink" title="BFC的功能"></a>BFC的功能</h2><h3 id="功能1：利用BFC包住内部浮动元素"><a href="#功能1：利用BFC包住内部浮动元素" class="headerlink" title="功能1：利用BFC包住内部浮动元素"></a>功能1：利用BFC包住内部浮动元素</h3><p>原始场景</p><p><img src="https://i.loli.net/2019/05/19/5ce106db0dcb483308.png" alt="BFC1.png"></p><p>给父元素加上overflow:hidden或者display:flow-root后触发bfc</p><p><img src="https://i.loli.net/2019/05/19/5ce107367397816878.png" alt="BFC2.png"></p><h3 id="功能2：利用BFC让兄弟元素划清界限"><a href="#功能2：利用BFC让兄弟元素划清界限" class="headerlink" title="功能2：利用BFC让兄弟元素划清界限"></a>功能2：利用BFC让兄弟元素划清界限</h3><p>原始场景</p><p><img src="https://i.loli.net/2019/05/19/5ce107ba5675d12762.png" alt="Image3.png"></p><p>给littleBro加上overflow:hidden或者display:flow-root 触发bfc</p><p><img src="https://i.loli.net/2019/05/19/5ce107e27392542001.png" alt="Image4.png"></p><h2 id="BFC的创建"><a href="#BFC的创建" class="headerlink" title="BFC的创建"></a>BFC的创建</h2><ol><li>浮动（float）</li><li>绝对定位（position:absolute）</li><li>非块盒的块容器：例如inline-block,table-cells,table-captions</li><li>overflow不为visible的块盒</li><li>display:flow-root 新增属性专门用于触发BFC，兼容性较差</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;BFC（blocking-formatting-context）&quot;&gt;&lt;a href=&quot;#BFC（blocking-formatting-context）&quot; class=&quot;headerlink&quot; title=&quot;BFC（blocking formatting cont
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>flex布局</title>
    <link href="http://yoursite.com/2019/05/19/flex%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2019/05/19/flex布局/</id>
    <published>2019-05-19T06:53:59.000Z</published>
    <updated>2019-05-19T07:21:12.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h1><h2 id="1、flex布局的特点"><a href="#1、flex布局的特点" class="headerlink" title="1、flex布局的特点"></a>1、flex布局的特点</h2><ol><li>flex布局与方向无关</li><li>空间自动分配，自动对齐</li><li>简单的线性布局</li></ol><h2 id="2、flex-container和item"><a href="#2、flex-container和item" class="headerlink" title="2、flex container和item"></a>2、flex container和item</h2><p><a href="https://i.loli.net/2019/05/19/5ce0ffdc46ae066188.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/05/19/5ce0ffdc46ae066188.png" alt="flex.png"></a></p><h3 id="flex-container属性介绍"><a href="#flex-container属性介绍" class="headerlink" title="flex container属性介绍"></a>flex container属性介绍</h3><ul><li>flex-direction：用来调整主轴和反转</li><li>flex-wrap: 是否换行</li><li>flex-flow 上面两个属性的简写</li><li>justify-content:用来调整主轴对齐方向</li><li>align-items:用来调整侧轴对齐方向</li><li>align-content:多行多列时调整对齐方向</li></ul><h3 id="flex-item属性介绍"><a href="#flex-item属性介绍" class="headerlink" title="flex item属性介绍"></a>flex item属性介绍</h3><ul><li>flex-grow:按比例分配空间</li><li>flex-shrink:按比例收缩空间</li><li>flex-basis:默认大小</li><li>flex: 上面三个属性的简写</li><li>order:顺序，用来代替双飞翼布局</li><li>align-self:自身对齐方式，优先级高于container的对齐方式</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;flex布局&quot;&gt;&lt;a href=&quot;#flex布局&quot; class=&quot;headerlink&quot; title=&quot;flex布局&quot;&gt;&lt;/a&gt;flex布局&lt;/h1&gt;&lt;h2 id=&quot;1、flex布局的特点&quot;&gt;&lt;a href=&quot;#1、flex布局的特点&quot; class=&quot;header
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>移动端页面</title>
    <link href="http://yoursite.com/2019/05/19/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B5%E9%9D%A2/"/>
    <id>http://yoursite.com/2019/05/19/移动端页面/</id>
    <published>2019-05-19T06:36:11.000Z</published>
    <updated>2019-05-19T06:51:24.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="移动端页面（响应式）的做法"><a href="#移动端页面（响应式）的做法" class="headerlink" title="移动端页面（响应式）的做法"></a>移动端页面（响应式）的做法</h1><h2 id="1、学会用媒体查询media-query"><a href="#1、学会用媒体查询media-query" class="headerlink" title="1、学会用媒体查询media query"></a>1、学会用媒体查询media query</h2><p>红极一时的bootstrap将响应式布局都归功于媒体查询media query，所以一定要学会媒体查询的使用。下面介绍一些基础写法:</p><p>1、判断页面最大宽度：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@media(max-width:800px)&#123;</span><br><span class="line">    <span class="selector-tag">body</span>&#123;</span><br><span class="line">        <span class="attribute">background</span>:red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、判断页面宽度在某一区间时：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@media(min-width:321px) and (max-width:800px)&#123;</span><br><span class="line">    <span class="selector-tag">body</span>&#123;</span><br><span class="line">        <span class="attribute">background</span>:red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、学会要设计图"><a href="#2、学会要设计图" class="headerlink" title="2、学会要设计图"></a>2、学会要设计图</h2><p>巧妇难为无米之炊，没有各个分辨率下的设计图还是别做响应式了吧</p><h2 id="3、学会隐藏元素"><a href="#3、学会隐藏元素" class="headerlink" title="3、学会隐藏元素"></a>3、学会隐藏元素</h2><p>尽量不要用js直接操作元素属性display:none的方式隐藏，而是改变元素的class样式。</p><h2 id="4、手机端要加一个-meta"><a href="#4、手机端要加一个-meta" class="headerlink" title="4、手机端要加一个 meta"></a>4、手机端要加一个 meta</h2><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;</code></p><h2 id="5、手机端的交互方式不一样"><a href="#5、手机端的交互方式不一样" class="headerlink" title="5、手机端的交互方式不一样"></a>5、手机端的交互方式不一样</h2><ol><li>没有 hover</li><li>有 touch 事件</li><li>没有 resize</li><li>没有滚动条</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;移动端页面（响应式）的做法&quot;&gt;&lt;a href=&quot;#移动端页面（响应式）的做法&quot; class=&quot;headerlink&quot; title=&quot;移动端页面（响应式）的做法&quot;&gt;&lt;/a&gt;移动端页面（响应式）的做法&lt;/h1&gt;&lt;h2 id=&quot;1、学会用媒体查询media-query&quot;
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>层叠顺序</title>
    <link href="http://yoursite.com/2019/05/19/%E5%B1%82%E5%8F%A0%E9%A1%BA%E5%BA%8F%E5%92%8C%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>http://yoursite.com/2019/05/19/层叠顺序和层叠上下文/</id>
    <published>2019-05-19T05:35:25.000Z</published>
    <updated>2019-05-19T06:15:53.075Z</updated>
    
    <content type="html"><![CDATA[<h1 id="层叠顺序和层叠上下文"><a href="#层叠顺序和层叠上下文" class="headerlink" title="层叠顺序和层叠上下文"></a>层叠顺序和层叠上下文</h1><p>默认情况下，网页内容是没有偏移角的垂直视觉呈现，当内容发生层叠的时候，一定会有一个前后的层叠顺序产生，而要理解网页中元素是如何“论资排辈”的，就需要深入理解CSS中的层叠上下文和层叠顺序。</p><h2 id="一、层叠上下文的概念"><a href="#一、层叠上下文的概念" class="headerlink" title="一、层叠上下文的概念"></a>一、层叠上下文的概念</h2><p>层叠上下文（Stacking context）是HTML中的一个三维的概念，如果一个元素含有层叠上下文，那么这个元素在Z轴上就要”高人一等“。这个Z轴指的就是眼睛与屏幕这条看不见的垂直线。</p><h2 id="二、层叠水平的概念"><a href="#二、层叠水平的概念" class="headerlink" title="二、层叠水平的概念"></a>二、层叠水平的概念</h2><p>层叠水平（Stacking level）决定了同一个层叠上下文中元素在z轴上的显示顺序。所有的元素都有层叠水平，包括层叠上下文元素。对于普通元素的层叠水平优先由层叠上下文决定，层叠水平的比较只有在当前层叠上下文元素中才有意义。</p><p>不要把层叠水平和CSS的z-index属性混为一谈。没错，某些情况下z-index确实可以影响层叠水平，但是，只限于定位元素以及flex盒子的孩子元素；而层叠水平所有的元素都存在。</p><h2 id="三、了解层叠顺序"><a href="#三、了解层叠顺序" class="headerlink" title="三、了解层叠顺序"></a>三、了解层叠顺序</h2><p><img src="https://i.loli.net/2019/05/19/5ce0f322dddc431970.png" alt="Markdown"></p><p>下面这两个是层叠领域的黄金准则。当元素发生层叠的时候，其覆盖关系遵循下面2个准则：</p><ol><li><strong>谁大谁上：</strong>当具有明显的层叠水平标示的时候，如识别的z-index值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个。</li><li><strong>后来居上：</strong>当元素的层叠水平一致、层叠顺序相同的时候，在DOM流中处于后面的元素会覆盖前面的元素。</li></ol><p>在CSS和HTML领域，只要元素发生了重叠，都离不开上面这两个黄金准则。</p><h2 id="四、层叠上下文的形成"><a href="#四、层叠上下文的形成" class="headerlink" title="四、层叠上下文的形成"></a>四、层叠上下文的形成</h2><p>可以理解为层叠作用域。跟 BFC 一样，我们只知道一些属性会触发层叠上下文，但并不知道层叠上下文是什么。</p><ul><li>根元素 (HTML),</li><li>z-index 值不为 “auto”的 绝对/相对定位，</li><li>一个 z-index 值不为 “auto”的 flex 项目 (flex item)，即：父元素 display: flex|inline-flex，</li><li>opacity 属性值小于 1 的元素（参考 the specification for opacity），</li><li>transform 属性值不为 “none”的元素，</li><li>mix-blend-mode 属性值不为 “normal”的元素，</li><li>filter值不为“none”的元素，</li><li>perspective值不为“none”的元素，</li><li>isolation 属性被设置为 “isolate”的元素，</li><li>position: fixed</li><li>在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值（参考 这篇文章）</li><li>-webkit-overflow-scrolling 属性被设置 “touch”的元素</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;层叠顺序和层叠上下文&quot;&gt;&lt;a href=&quot;#层叠顺序和层叠上下文&quot; class=&quot;headerlink&quot; title=&quot;层叠顺序和层叠上下文&quot;&gt;&lt;/a&gt;层叠顺序和层叠上下文&lt;/h1&gt;&lt;p&gt;默认情况下，网页内容是没有偏移角的垂直视觉呈现，当内容发生层叠的时候，一定会
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>VSCode前端开发插件配置</title>
    <link href="http://yoursite.com/2019/05/19/VSCode%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/05/19/VSCode前端开发插件配置/</id>
    <published>2019-05-19T02:38:13.000Z</published>
    <updated>2019-05-19T02:40:52.985Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VSCode前端开发插件配置"><a href="#VSCode前端开发插件配置" class="headerlink" title="VSCode前端开发插件配置"></a>VSCode前端开发插件配置</h1><p>作为前端开发人员，拥有一款适合自己的编辑器无异于如虎添翼，之前经常使用SumlimeText的我首次试用VSCode就有一种心动的感觉。VSCode这款免费的编辑器颜值够高，合理配置插件后也可以媲美WebStorm这种硬核的编辑器，那么你还有什么理由拒绝它呢。</p><p>每每上手新的编辑器，我都会根据自己的开发习惯把它调较到理想状态，加上熟悉编辑器各种特性，这个过程通常需要几周的时间。接下来，我就从外观配置、风格检查、编码效率、功能增强等 4 方面来侃侃怎么配置 VSCode 来提高工作幸福感。</p><h2 id="外观配置"><a href="#外观配置" class="headerlink" title="外观配置"></a>外观配置</h2><p>作为前端开发者，外观当然是最先考虑的部分，从配置的角度，无非是配色、图标、字体等，俗话说萝卜白菜各有所爱，我目前的配色、图标字体如下：</p><ul><li>配色：One Dark Pro，在VSCode Extensions中搜索One Dark Pro安装即可</li><li>图标：Material Icon Theme，给不同类型的文件配置不同的图标，非常直观；</li><li>字体：Fira Code，自从发现并开始使用 Fira Code，我就再也没多看自其它字体一眼，字体如果比较优雅，尤其是对数学运算符的处理</li><li><h2 id="风格检查"><a href="#风格检查" class="headerlink" title="风格检查"></a>风格检查</h2></li><li><p>保障优秀一致的代码风格是一个程序员的高尚品质，如果编辑器在编码时实时给出反馈，对开发者个人而言才是最高效的，在提交时做强制检查只是从团队的视角保证编码风格的规范性和一致性。前端工程师会书写的代码无非是：HTML、CSS、Javascript、Markdown、TypeScript、JSON，对应的 Lint 工具就显而易见：</p></li><li>ESLint：插件式架构，有多种主流的编码风格规则集可供选择，典型的有 Airbnb、Google 等</li><li>StyleLint，同样插件式架构的样式检查工具</li><li>TSLint：编写TypeScript你会想用到它的 </li><li>MarkdownLint：Markdown 如果不合法，可能在某些场合导致解析器异常，因为 Markdown 有好几套标准，在不同标准间部分语法支持可能是不兼容的；</li></ul><p>有了风格检查，自然就会产生按配置好的风格规则做文件格式化的需求，另外推荐一款好用的格式化工具：Prettier，实际上已经是代码格式化的工具标准，支持格式化几乎所有的前端代码，并且类似于 EditorConfig 支持用文件来配置格式规则；</p><h2 id="编码效率"><a href="#编码效率" class="headerlink" title="编码效率"></a>编码效率</h2><p>说到编码效率，当你感觉击键的速率已经赶不上自己的思维时就需要在编码时设置适当的快捷键，组合使用智能建议、代码片段、自动补全来达到速度的最大化。重点说说代码片段和自动补全两个效率提升利器。代码片段英文叫做 Snippets，市面上主流的编辑器也都支持，其基本思想就是把常见的代码模式抽出来，通过 2~3 个键就能展开 N 行代码，代码片段的积累一方面是根据个人习惯，另一方面是学习社区里面积累出来的好的编码模式，如果觉得不适合你，可以改（找个现有的插件依葫芦画瓢）</p><h3 id="常用的代码片段插件"><a href="#常用的代码片段插件" class="headerlink" title="常用的代码片段插件"></a>常用的代码片段插件</h3><ul><li>HTML Snippets，各种 HTML 标签片段，如果你 Emmet 玩的熟，完全可以忽略这个</li><li>Javascript (ES6) Code Snippets，常用的类声明、ES 模块声明、CMD 模块导入等，支持的缩写不下 20 种</li><li>Javascript Patterns Snippets，常见的编码模式，比如 IIFE；自动补全自动补全本质上和代码片段类似，不过是在特殊场合下以你的键入做为启发式信息提供最有可能要输入的建议</li></ul><h3 id="常用的自动补全工具"><a href="#常用的自动补全工具" class="headerlink" title="常用的自动补全工具"></a>常用的自动补全工具</h3><ul><li>Auto Close Tag，适用于 JSX、Vue、HTML，在打开标签并且键入 &lt;/ 的时候，能自动补全要闭合的标签；</li><li>Auto Rename Tag，适用于 JSX、Vue、HTML，在修改标签名时，能在你修改开始（结束）标签的时候修改对应的结束（开始）标签，帮你减少 50% 的击键</li><li>Path Intellisense，文件路径补全，在你用任何方式引入文件系统中的路径时提供智能提示和自动完成；NPM Intellisense，NPM 依赖补全，在你引入任何 node_modules 里面的依赖包时提供智能提示和自动完成</li><li>IntelliSense for CSS class names，CSS 类名补全，会自动扫描整个项目里面的 CSS 类名并在你输入类名时做智能提示</li><li>Emmet，以前叫做 Zen Coding，我发现后，也是爱不释手，可以把类 CSS 选择符的字符串展开成 HTML 标签，VSCode 已经内置，官方介绍文档参见，你需要做的就是熟悉他的语法，并勤加练习</li></ul><h3 id="TODO-Highlight"><a href="#TODO-Highlight" class="headerlink" title="TODO Highlight"></a>TODO Highlight</h3><p>维护时间稍长的代码仓库免不了会有各种 TODO、FIXME、HACK 之类的标记，TODO Highlight 能够帮我们把这些关键词高亮出来，在你翻阅代码时非常醒目，就像是在大声提醒你尽快把他解决掉。支持自定义配置需要高亮的关键词，实际使用比较坑的地方是，TODO、FIXME 之类的后面必须加上冒号，否则无法高亮。</p><p>功能增强在效率提升方面除了上面的代码片段、自动补全之外，我还安装了下面几个插件，方便快速的浏览和理解代码，并且在不同项目之间切换。</p><ul><li>Color Highlight，识别代码中的颜色，包括各种颜色格式；</li><li>Bracket Pair Colorizer，识别代码中的各种括号，并且标记上不同的颜色，方便你扫视到匹配的括号，在括号使用非常多的情况下能环节眼部压力，编辑器快捷键固然好用，但是在临近嵌套多的情况下却有些力不从心；</li><li>Project Manager，项目管理，让我们方便的在命令面板中切换项目文件夹，当然，你也可以直接打开包含多个项目的父级文件夹，但这样可能会让 VSCode 变慢；</li></ul><h2 id="不同设备同步VSCode配置"><a href="#不同设备同步VSCode配置" class="headerlink" title="不同设备同步VSCode配置"></a>不同设备同步VSCode配置</h2><h3 id="Settings-Sync"><a href="#Settings-Sync" class="headerlink" title="Settings Sync"></a>Settings Sync</h3><p>Settings Sync 基于 Gist 实现 VSCode 用户配置、快捷键配置、已安装插件列表等的备份和恢复功能，配置过程有详细精确的操作步骤文档。生成的备份 Gist 默认是私密的，如果你想设置为共享的，也可以一键切换。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;VSCode前端开发插件配置&quot;&gt;&lt;a href=&quot;#VSCode前端开发插件配置&quot; class=&quot;headerlink&quot; title=&quot;VSCode前端开发插件配置&quot;&gt;&lt;/a&gt;VSCode前端开发插件配置&lt;/h1&gt;&lt;p&gt;作为前端开发人员，拥有一款适合自己的编辑器无
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="VSCode" scheme="http://yoursite.com/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>CSS进阶笔记</title>
    <link href="http://yoursite.com/2019/05/19/CSS%E8%BF%9B%E9%98%B6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/05/19/CSS进阶笔记/</id>
    <published>2019-05-19T00:49:29.000Z</published>
    <updated>2019-05-19T05:11:12.031Z</updated>
    
    <content type="html"><![CDATA[<h1 id="标准流Normal-Flow"><a href="#标准流Normal-Flow" class="headerlink" title="标准流Normal Flow"></a>标准流Normal Flow</h1><h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><h3 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h3><ul><li><p>宽度固定：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line"> <span class="attribute">margin-left</span>: auto;</span><br><span class="line">    <span class="attribute">margin-right</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>宽度不固定：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="内联元素"><a href="#内联元素" class="headerlink" title="内联元素"></a>内联元素</h3><p>设置内联元素的父元素text-align属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><p>不兼容IE时，可以使用flex布局简单实现：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>兼容IE时，可以使用table布局</p><h2 id="文字溢出省略"><a href="#文字溢出省略" class="headerlink" title="文字溢出省略"></a>文字溢出省略</h2><ul><li><p>单行文字溢出省略：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>多行文字溢出省略：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">     <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">     <span class="attribute">-webkit-line-clamp</span>: <span class="number">2</span>; <span class="comment">/*在这里设置行数*/</span></span><br><span class="line">     <span class="attribute">-webkit-box-orient</span>: vertical; </span><br><span class="line">     <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><h3 id="盒模型分类：W3C标准盒模型和IE盒模型"><a href="#盒模型分类：W3C标准盒模型和IE盒模型" class="headerlink" title="盒模型分类：W3C标准盒模型和IE盒模型"></a>盒模型分类：W3C标准盒模型和IE盒模型</h3><p> 盒模型分为W3C标准盒模型和IE盒模型。在ie8+浏览器中使用哪个盒模型可以由<strong>box-sizing</strong>(CSS新增的属性)控制，默认值为content-box，即标准盒模型；如果将box-sizing设为border-box则用的是IE盒模型。如果在ie6,7,8中DOCTYPE缺失会触发IE模式。在当前W3C标准中盒模型是可以通过box-sizing自由的进行切换的。</p><ol><li>W3C标准盒模型：属性width和height只包含content,不包含padding和border</li><li>IE盒模型：属性width,height包含border和padding，指的是content+padding+border。</li></ol><h3 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a>调试方法</h3><p>要学会使用border进行CSS的调试，可以说不会border调试方法就不要写CSS啦~.~</p><h3 id="实现一个宽度自适应的1-1的div"><a href="#实现一个宽度自适应的1-1的div" class="headerlink" title="实现一个宽度自适应的1:1的div"></a>实现一个宽度自适应的1:1的div</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;标准流Normal-Flow&quot;&gt;&lt;a href=&quot;#标准流Normal-Flow&quot; class=&quot;headerlink&quot; title=&quot;标准流Normal Flow&quot;&gt;&lt;/a&gt;标准流Normal Flow&lt;/h1&gt;&lt;h2 id=&quot;水平居中&quot;&gt;&lt;a href=&quot;#水
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>CSS学习笔记</title>
    <link href="http://yoursite.com/2019/05/09/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/05/09/CSS学习笔记/</id>
    <published>2019-05-09T12:21:25.000Z</published>
    <updated>2019-05-19T00:53:38.247Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS学习笔记"><a href="#CSS学习笔记" class="headerlink" title="CSS学习笔记"></a>CSS学习笔记</h1><h2 id="导航栏的CSS简单实现"><a href="#导航栏的CSS简单实现" class="headerlink" title="导航栏的CSS简单实现"></a>导航栏的CSS简单实现</h2><p>利用css可以将垂直展示的ul,ol列表转变为水平展示的导航栏<br><strong>html代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class=&quot;clearfix&quot;&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;关于&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;技能&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;作品&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;博客&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;日历&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;联系方式&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;其他&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p><strong>css代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">clearfix::after&#123;</span><br><span class="line">    content:&quot;&quot;;</span><br><span class="line">    display:block;</span><br><span class="line">    clear:both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">li &#123;</span><br><span class="line">float: left;</span><br><span class="line">margin-left: 17px;</span><br><span class="line">margin-right: 17px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以记住口诀：子元素加float属性，父元素使用clearfix</p><h2 id="高度是由什么决定的"><a href="#高度是由什么决定的" class="headerlink" title="高度是由什么决定的"></a>高度是由什么决定的</h2><h3 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h3><p>块级元素相对简单，高度是由其内部文档流高度总和决定的。那么什么是文档流呢？文档流即是文档内的元素流动方向。内联元素是从左往右流动的，当宽度不足时，自动换行。块级元素是从上往下流动的。</p><h3 id="内联元素"><a href="#内联元素" class="headerlink" title="内联元素"></a>内联元素</h3><p>内联元素相对复杂，其中font-size的问题最为经典，font-size的值指字体最低的部分到字体最高部分的距离，而为了展示效果，默认行高根据不同字体有所差异。我们也可以通过line-height属性来设置建议行高，然后只有在字体大小较小时，line-height才生效。</p><h2 id="css画一个三角形"><a href="#css画一个三角形" class="headerlink" title="css画一个三角形"></a>css画一个三角形</h2><p>html代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;triangle&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>css代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.triangle&#123;</span><br><span class="line">  width:0;</span><br><span class="line">  border:20px solid transparent;</span><br><span class="line">  border-top-width:0;</span><br><span class="line">  border-left-color:blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CSS学习笔记&quot;&gt;&lt;a href=&quot;#CSS学习笔记&quot; class=&quot;headerlink&quot; title=&quot;CSS学习笔记&quot;&gt;&lt;/a&gt;CSS学习笔记&lt;/h1&gt;&lt;h2 id=&quot;导航栏的CSS简单实现&quot;&gt;&lt;a href=&quot;#导航栏的CSS简单实现&quot; class=&quot;he
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>HTTP常用标签</title>
    <link href="http://yoursite.com/2019/05/08/HTTP%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"/>
    <id>http://yoursite.com/2019/05/08/HTTP常用标签/</id>
    <published>2019-05-08T15:03:57.000Z</published>
    <updated>2019-05-19T00:53:44.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML常用标签"><a href="#HTML常用标签" class="headerlink" title="HTML常用标签"></a>HTML常用标签</h1><h2 id="HTML-常用标签"><a href="#HTML-常用标签" class="headerlink" title="HTML 常用标签"></a>HTML 常用标签</h2><h3 id="iframe标签"><a href="#iframe标签" class="headerlink" title="iframe标签"></a>iframe标签</h3><p><strong>HTML内联框架元素 </strong> iframe表示嵌套的浏览上下文，有效地将另一个HTML页面嵌入到当前页面中。</p><p><strong>属性</strong></p><p><strong>frameborder</strong> </p><p>取值为1时（默认值），告诉浏览器在当前iframe与其他iframe之间绘制边框，取0时则无需绘制此边框。默认的比较丑，一般取0。</p><p><strong>height</strong></p><p>以CSS像素格式指定frame的高度。</p><p><strong>width</strong></p><p>以CSS像素格式或以百分比格式指定frame的宽度。</p><p><strong>name</strong></p><p>嵌入的浏览上下文（框架）的名称。该名称可以用作标签a，form的<code>target</code>属性值，或者标签input，button的<code>formtaget</code>属性值。</p><p><strong>src</strong></p><p>嵌套页面的URL地址。使用遵守同源策略的  <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy#Inherited_origins" target="_blank" rel="noopener">‘about:blank’</a> 来嵌套空白页。</p><hr><h3 id="a标签"><a href="#a标签" class="headerlink" title="a标签"></a>a标签</h3><p><strong>HTML</strong>  元素  (或锚元素) 可以创建一个到其他网页、文件、同一页面内的位置、电子邮件地址或任何其他URL的超链接。</p><p><strong>属性</strong></p><p><strong>download</strong></p><p>此属性指示浏览器下载URL或者文件而不是导航到它，因此将提示用户将其保存为本地文件。<strong>此属性仅使用于**</strong>同源URL**, 如果不是同源(同域), 将会导航到该URL, 例如:</p><ul><li><p><code>&lt;a href=&quot;http://127.0.0.1:8080/index.html&quot; download=&quot;index&quot;&gt;下载&lt;/a&gt;</code> 会下载同源的一个index.html</p></li><li><p><code>&lt;a href=&quot;http://qq.com&quot; download=&quot;qq&quot;&gt;下载&lt;/a&gt;</code>, <code>download</code>无效, 将导航到qq.com</p><p><code>target</code>: 该属性指定在何处显示链接的资源。 取值为标签（tab），窗口（window），或框架（iframe）等浏览上下文的名称或其他关键词。</p></li><li><p><code>target=&quot;_self&quot;</code>: 当前页面加载, 如果没有指定此属性的话, 该值是默认值.</p></li><li><p><code>target=&quot;_blank&quot;</code>: 新窗口打开</p></li><li><p><code>target=&quot;_parent&quot;</code>: 会加载到当前页面的父页面, 如果没有父页面,则等同于<code>_self</code></p></li><li><p><code>targe=&quot;_top&quot;</code>: 会加载到最顶层页面, 祖先级页面, 当index1.html包含index2.html, index2.html包含index3.html, 则index3.html中的跳转则会加载到index1.html上</p></li></ul><p><strong>href</strong></p><p>包含超链接指向的URL或URL片段。</p><ul><li><code>&lt;a href=&quot;qq.com&quot;&gt;QQ&lt;/a&gt;</code>:,点击QQ不会跳转到qq.com 会把qq.com当成文件, <strong>不是以.com为后缀就是网址,也可以是文件</strong></li><li><code>&lt;a href=&quot;//qq.com&quot;&gt;QQ&lt;/a&gt;</code>, 不写协议的时候, 无协议绝对地址, 默认是当前页面协议, 是file协议, 就跳转file://qq.com, 是HTTP协议, 就跳转到<a href="http://qq.com" target="_blank" rel="noopener">http://qq.com</a></li><li><code>&lt;a href=&quot;xxx.html&quot;&gt;xxx&lt;/a&gt;</code>, 相对路径, 路径只会以目录为参考, 如果在index.html中跳转, 并不会以index.html为前缀<code>index.html/xxx.html</code>, 会显示<code>xxx.html</code></li><li><code>&lt;a href=&quot;#1&quot;&gt;1ink&lt;/a&gt;</code>, 写锚点, 会自动加到后面, 不会发起请求, <code>index.html#1</code>, 虽然不会发起请求,但是页面会有变化.</li><li><code>&lt;a href=&quot;?name=xxx&quot;&gt;query&lt;/a&gt;</code>, 写参数, 会自动加到后面, 并发起GET请求, <code>index.html?name=xxx</code></li><li><code>&lt;a href=&quot;javascript: alert(1)&quot;&gt;js&lt;/a&gt;</code>, 伪协议, 会执行js代码.</li><li><code>&lt;a href=&quot;javascript:;&quot;&gt;js&lt;/a&gt;</code>, 伪协议, 使其标签点击而不做任何动作，可以实现某些奇葩需求</li><li><code>&lt;a href=&quot;&quot;&gt;blank&lt;/a&gt;</code>, 什么也不写, 页面会刷新, 跳转到了自己.</li></ul><p><strong>name</strong></p><p>和iframe配合使用</p><hr><h3 id="form标签"><a href="#form标签" class="headerlink" title="form标签"></a>form标签</h3><p><strong>HTML</strong>元素</p><p>表示了文档中的一个区域，这个区域包含有交互控制元件，用来向web服务器提交信息。</p><blockquote><p><strong>a标签和form标签都是跳转, 区别就是a标签发起的是GET请求, form标签发起的是POST请求.</strong></p></blockquote><p><strong>属性</strong></p><p><strong>action</strong><br>提交(POST)数据所到的地方.<code>action=&quot;users&quot;</code>, 就是提交到users, 一个处理这个form信息的程序所在的URL.<br><strong>method</strong><br>浏览器使用这种指定方式来提交 form, GET一般不用写, 如果是GET, 提交的数据会被作为查询参数, 并不会放到第四部分作为formdata, POST会把提交的数据放到formdata里, 如果要给POST加查询参数, 可以通过给URL加查询参数<code>?query=xxx</code><br> <strong>target</strong><br>和a标签相同<br><strong>name</strong><br>HTML5中，一个文档中的多个form当中，name必须唯一而不仅仅是一个空字符串. 也可以与<strong>iframe标签</strong>配合使用.</p><p><strong>如果form标签没有提交按钮, 则无法提交, html里只有form标签能提交数据，提交按钮可以是有一个 input type=submit 的元素或者有一个 button 元素，button 的 type 属性为空</strong></p><hr><h3 id="input标签"><a href="#input标签" class="headerlink" title="input标签"></a>input标签</h3><p><strong>HTML input 元素</strong>用于为基于Web的表单创建交互式控件，以便接受来自用户的数据。使用input标签提交数据, 必须有name属性.</p><p><strong>属性</strong></p><p><strong>type</strong><br> 要呈现的控件类型</p><ul><li><code>type=&quot;button&quot;</code>: 普通按钮 </li><li><code>type=&quot;checkbox&quot;</code>: 复选框。必须使用 value 属性定义此控件被提交时的值</li><li><code>color</code>： 用于指定颜色的控件。</li><li><code>date：</code>用于输入日期的控件（年，月，日，不包括时间）。</li><li><code>datetime</code>：基于 UTC 时区的日期时间输入控件（时，分，秒及几分之一秒）。</li><li><code>datetime-local</code>：用于输入日期时间控件，不包含时区。</li><li><code>email</code>：用于编辑 e-mail 的字段。 合适的时候可以使用 </li><li><code>file</code>：此控件可以让用户选择文件。使用 accept 属性可以定义控件可以选择的文件类型。</li><li><code>hidden</code>：不显示在页面上的控件，但它的值会被提交到服务器。</li><li><code>image</code>：图片提交按钮。必须使用 src 属性定义图片的来源及使用 alt 定义替代文本。还可以使用 height 和 width 属性以像素为单位定义图片的大小。</li><li><code>month</code>：用于输入年月的控件，不带时区。</li><li><code>number</code>:用于输入浮点数的控件。</li><li><code>password</code>：一个值被遮盖的单行文本字段。使用 maxlength 指定可以输入的值的最大长度 。</li><li><code>radio</code>：单选按钮。必须使用 value 属性定义此控件被提交时的值。使用checked 必须指示控件是否缺省被选择。在同一个”单选按钮组“中，所有单选按钮的 name 属性使用同一个值； 一个单选按钮组中是，同一时间只有一个单选按钮可以被选择。 </li><li><code>reset</code>：用于将表单所内容设置为缺省值的按钮。</li><li><code>search</code>：用于输入搜索字符串的单行文本字段。换行会被从输入的值中自动移除。</li><li><code>submit</code>：用于提交表单的按钮。</li><li><code>tel</code>： 用于输入电话号码的控件；换行会被自动从输入的值中移除A，但不会执行其他语法。可以使用属性，比如 pattern 和 maxlength 来约束控件输入的值。恰当的时候，可以应用 </li><li><code>text</code>：单行字段；换行会将自动从输入的值中移除。</li><li><code>time</code>：用于输入不含时区的时间控件。</li><li><code>url</code>：用于编辑URL的字段。 The user may enter a blank or invalid address. 换行会被自动从输入值中移队。可以使用如：pattern 和 maxlength 样的属性来约束输入的值。 恰当的时候使可以应用 </li><li><code>week</code>：用于输入一个由星期-年组成的日期，日期不包括时区。</li></ul><p><strong>autocomplete</strong><br>这个属性表示这个控件的值是否可被浏览器自动填充。如果<strong>type</strong>属性的值是hidden、checkbox、radio、file，或为按钮类型（button、submit、reset、image），则本属性被忽略。</p><p><strong>autofocus</strong><br>这个布尔属性允许您指定的表单控件在页面加载时具有焦点（自动获得焦点），除非用户将其覆盖，例如通过键入不同的控件。文档中只有一个表单元素可以具有autofocus属性，它是一个布尔值。 如果type属性设置为隐藏则不能应用（即您不能自动获得焦点的属性设置为隐藏的控件）。</p><p><strong>disabled</strong><br>这个布尔属性表示此表单控件不可用。 特别是在禁用的控件中， <code>click</code> 事件 [将不会被分发]。 并且，禁用的控件的值在提交表单时也不会被提交。如果 <strong>type</strong> 属性为  hidden，此属性将被忽略。</p><p><strong>小Tips:可以使用将input元素嵌入到label元素中达到点击文本时自动将焦点移动到input上元素上</strong></p><hr><h3 id="button标签"><a href="#button标签" class="headerlink" title="button标签"></a>button标签</h3><p><strong>HTML button 元素</strong>表示一个可点击的按钮，可以用在表单或文档其它需要使用简单标准按钮的地方</p><p><strong>input和button区别</strong>: 是否是空元素, button有子元素, input没有</p><p><strong>属性</strong></p><p><strong>type</strong><br>button的类型</p><ul><li><code>submit</code>:  此按钮将表单数据提交给服务器。如果未指定属性，或者属性动态更改为空值或无效值，则此值为默认值。</li><li><code>reset</code>:  此按钮重置所有组件为初始值。</li><li><code>button</code>: 此按钮没有默认行为。它可以有与元素事件相关的客户端脚本，当事件出现时可触发。</li><li><code>menu</code>: 此按钮打开一个由指定元素进行定义的弹出菜单。</li></ul><p><strong>name</strong><br>button的名称，与表单数据一起提交。</p><p><strong>value</strong><br>button的初始值。它定义的值与表单数据的提交按钮相关联。当表单中的数据被提交时，这个值便以参数的形式被递送至服务器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTML常用标签&quot;&gt;&lt;a href=&quot;#HTML常用标签&quot; class=&quot;headerlink&quot; title=&quot;HTML常用标签&quot;&gt;&lt;/a&gt;HTML常用标签&lt;/h1&gt;&lt;h2 id=&quot;HTML-常用标签&quot;&gt;&lt;a href=&quot;#HTML-常用标签&quot; class=&quot;he
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>HTTP请求和响应初探</title>
    <link href="http://yoursite.com/2019/05/04/HTTP%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E5%88%9D%E6%8E%A2/"/>
    <id>http://yoursite.com/2019/05/04/HTTP请求和响应初探/</id>
    <published>2019-05-04T13:23:27.000Z</published>
    <updated>2019-05-19T00:53:49.797Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP请求和响应初探"><a href="#HTTP请求和响应初探" class="headerlink" title="HTTP请求和响应初探"></a>HTTP请求和响应初探</h1><p>HTTP协议作为前端开发者必须掌握的知识点，它的作用就是知道浏览器和服务器如何进行沟通。下面我们就分别用命令行和Chrome开发者工具来初步探索HTTP请求和响应的内容。</p><h2 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h2><h3 id="使用命令行curl命令请求示例"><a href="#使用命令行curl命令请求示例" class="headerlink" title="使用命令行curl命令请求示例"></a>使用命令行curl命令请求示例</h3><p>在命令行中输入如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s -v -H <span class="string">"User: xxx"</span> -- <span class="string">"https://www.baidu.com"</span></span><br></pre></td></tr></table></figure><p>简单分析一下我们创造的命令，curl用来创造一个请求，-s是-silent的缩写，表示不显示进度条和错误信息，-v是-verbose的缩写，常用于debug时候查找详细信息，-H “User: xxx”表示自定义一个header。接下来我们关注一下命令行显示的请求内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: www.baidu.com</span><br><span class="line">User-Agent: curl/7.63.0</span><br><span class="line">Accept: */*</span><br><span class="line">User: xxx</span><br></pre></td></tr></table></figure><p>然后我们把请求的方式变成POST，在命令行中输入如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -s -v -H <span class="string">"User: xxx"</span> -- <span class="string">"https://www.baidu.com"</span></span><br></pre></td></tr></table></figure><p>得到的请求内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: www.baidu.com</span><br><span class="line">User-Agent: curl/7.63.0</span><br><span class="line">Accept: */*</span><br><span class="line">User: xxx</span><br></pre></td></tr></table></figure><p>​    </p><p>我们继续在POST请求的基础上加入-d data内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -d <span class="string">"1234567890"</span> -s -v -H <span class="string">"User: xxx"</span> -- <span class="string">"https://www.baidu.com"</span></span><br></pre></td></tr></table></figure><p>得到的请求内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: www.baidu.com</span><br><span class="line">User-Agent: curl/7.63.0</span><br><span class="line">Accept: */*</span><br><span class="line">User: xxx</span><br><span class="line">Content-Length: 10</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">1234567890</span><br></pre></td></tr></table></figure><p>​                                                                                                                               `</p><h3 id="使用Chrome开发者工具查看请求内容"><a href="#使用Chrome开发者工具查看请求内容" class="headerlink" title="使用Chrome开发者工具查看请求内容"></a>使用Chrome开发者工具查看请求内容</h3><ol><li>打开chrome,按F12，点击Network</li><li>输入网址<a href="https://www.baidu.com/" target="_blank" rel="noopener">https://www.baidu.com/</a></li><li>选中第一个响应</li><li>查看 Request Headers，点击「view source」，会看到如下图所示的请求内容</li></ol><h3 id="请求的格式"><a href="#请求的格式" class="headerlink" title="请求的格式"></a>请求的格式</h3><p>我们已经通过curl命令和Chorme开发者工具两种方式看到了HTTP的请求内容，下面我们总结一下HTTP请求的格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 动词 路径 协议/版本</span><br><span class="line">2 Key1: value1</span><br><span class="line">2 Key2: value2</span><br><span class="line">2 Key3: value3</span><br><span class="line">2 Content-Type: application/x-www-form-urlencoded</span><br><span class="line">2 Host: www.baidu.com</span><br><span class="line">2 User-Agent: curl/7.54.0</span><br><span class="line">3 </span><br><span class="line">4 要上传的数据</span><br></pre></td></tr></table></figure><ol><li>请求最多包含四部分，最少包含三部分。（也就是说第四部分可以为空）</li><li>第三部分永远都是一个回车（<code>\n</code>）</li><li>动词有 GET POST PUT PATCH DELETE HEAD OPTIONS 等</li><li>这里的路径包括「查询参数」，但不包括「锚点」</li><li>如果你没有写路径，那么路径默认为 /</li><li>第 2 部分中的 Content-Type 标注了第 4 部分的格式</li><li>第3部分只是一个空行，目的是为了区分第2部分和第4部分要上传的数据</li></ol><h2 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h2><p>请求了之后，应该都能得到一个响应，除非断网了，或者服务器宕机了。</p><h3 id="响应示例"><a href="#响应示例" class="headerlink" title="响应示例"></a>响应示例</h3><p>上面三个请求示例，前两个请求对应的响应分别为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Length: 2443</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Date: Tue, 10 Oct 2017 09:14:05 GMT</span><br><span class="line">Etag: &quot;5886041d-98b&quot;</span><br><span class="line">Last-Modified: Mon, 23 Jan 2017 13:24:45 GMT</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Server: bfe/1.0.8.18</span><br><span class="line">Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt; 后面太长，省略了……</span><br><span class="line">HTTP/1.1 302 Found</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Length: 17931</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Date: Tue, 10 Oct 2017 09:19:47 GMT</span><br><span class="line">Etag: &quot;54d9749e-460b&quot;</span><br><span class="line">Server: bfe/1.0.8.18</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt; 后面太长，省略了……</span><br></pre></td></tr></table></figure><ol><li>GET 请求和 POST 请求对应的响应可以一样，也可以不一样</li><li>响应的第四部分可以很长很长很长</li></ol><h3 id="响应的格式"><a href="#响应的格式" class="headerlink" title="响应的格式"></a>响应的格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 协议/版本号 状态码 状态解释</span><br><span class="line">2 Key1: value1</span><br><span class="line">2 Key2: value2</span><br><span class="line">2 Content-Length: 17931</span><br><span class="line">2 Content-Type: text/html</span><br><span class="line">3</span><br><span class="line">4 要下载的内容</span><br></pre></td></tr></table></figure><ul><li>状态码要背，是服务器对浏览器说的话<ul><li>1xx 不常用</li><li>2xx 表示成功</li><li>3xx 表示滚吧</li><li>4xx 表示你丫错了</li><li>5xx 表示好吧，我错了</li></ul></li><li>状态解释没什么用</li><li>第 2 部分中的 Content-Type 标注了第 4 部分的格式</li><li>第 2 部分中的 Content-Type 遵循 MIME 规范</li></ul><h3 id="用-Chrome-查看响应"><a href="#用-Chrome-查看响应" class="headerlink" title="用 Chrome 查看响应"></a>用 Chrome 查看响应</h3><ol><li>打开 Network</li><li>输入网址</li><li>选中第一个响应</li><li>查看 Response Headers，点击「view source」</li><li>你会看到响应的前两部分</li><li>查看 Response 或者 Preview，你会看到响应的第 4 部分</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTTP请求和响应初探&quot;&gt;&lt;a href=&quot;#HTTP请求和响应初探&quot; class=&quot;headerlink&quot; title=&quot;HTTP请求和响应初探&quot;&gt;&lt;/a&gt;HTTP请求和响应初探&lt;/h1&gt;&lt;p&gt;HTTP协议作为前端开发者必须掌握的知识点，它的作用就是知道浏览器和
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
</feed>
